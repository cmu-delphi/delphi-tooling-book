{
  "hash": "bb0ef2877b6abb6d5c2babf133097d58",
  "result": {
    "markdown": "# Introducing the flatline forecaster\n\nThe flatline forecaster is a very simple forecasting model intended for `epi_df` data, where the most recent observation is used as the forecast for any future date. In other words, the last observation is propagated forward. Hence, a flat line phenomenon is observed for the point predictions. The predictive intervals are produced from the quantiles of the residuals of such a forecast over all of the training data. By default, these intervals will be obtained separately for each combination of keys (`geo_value` and any additional keys) in the `epi_df`. Thus, the output is a data frame of point (and optionally interval) forecasts at a single unique horizon (`ahead`) for each unique combination of key variables. This forecaster is comparable to the baseline used by the [COVID Forecast Hub](https://covid19forecasthub.org).\n\n## Example of using the flatline forecaster\n\n\n::: {.cell}\n\n:::\n\n\n\nWe will continue to use the `case_death_rate_subset` dataset that comes with the\n`epipredict` package. In brief, this is a subset of the JHU daily COVID-19 cases\nand deaths by state. While this dataset ranges from Dec 31, 2020 to Dec 31, \n2021, we will only consider a small subset at the end of that range to keep our\nexample relatively simple.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-2_bdb1903df82234e00ed17b2089a9dcf7'}\n\n```{.r .cell-code}\njhu <- case_death_rate_subset %>%\n  dplyr::filter(time_value >= as.Date(\"2021-09-01\"))\n\njhu\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> An `epi_df` object, 6,832 x 4 with metadata:\n#> * geo_type  = state\n#> * time_type = day\n#> * as_of     = 2022-05-31 12:08:25\n#> \n#> # A tibble: 6,832 × 4\n#>   geo_value time_value case_rate death_rate\n#> * <chr>     <date>         <dbl>      <dbl>\n#> 1 ak        2021-09-01      75.3      0.198\n#> 2 al        2021-09-01     113.       0.845\n#> 3 ar        2021-09-01      68.5      0.919\n#> 4 as        2021-09-01       0        0    \n#> 5 az        2021-09-01      48.8      0.414\n#> 6 ca        2021-09-01      38.4      0.246\n#> # ℹ 6,826 more rows\n```\n:::\n:::\n\n\n### The basic mechanics of the flatline forecaster\n\nThe simplest way to create and train a flatline forecaster to predict the d\neath rate one week into the future, is to input the `epi_df` and the name of \nthe column from it that we want to predict in the `flatline_forecaster` function.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-3_d9bff13811c7ad711033cc306bce0068'}\n\n```{.r .cell-code}\none_week_ahead <- flatline_forecaster(jhu, outcome = \"death_rate\")\none_week_ahead\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n#> ══ A basic forecaster of type flatline ══════════════════════════════════════\n#> \n#> This forecaster was fit on 2023-06-27 10:43:54\n#> \n#> Training data was an `epi_df` with\n#> • Geography: state,\n#> • Time type: day,\n#> • Using data up-to-date as of: 2022-05-31 12:08:25.\n#> \n#> ── Predictions ──────────────────────────────────────────────────────────────\n#> \n#> A total of 56 predictions are available for\n#> • 56 unique geographic regions,\n#> • At forecast dates: 2021-12-31,\n#> • For target dates: 2022-01-07.\n```\n:::\n:::\n\n\nThe result is both a fitted model object which could be used any time in the \nfuture to create different forecasts, as well as a set of predicted values and\nprediction intervals for each location 7 days after the last available time\nvalue in the data, which is Dec 31, 2021. Note that 7 days is the default\nnumber of time steps ahead of the forecast date in which forecasts should be\nproduced. To change this, you must change the value of the `ahead` parameter\nin the list of additional arguments `flatline_args_list()`. Let's change this\nto 5 days to get some practice.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-4_013bf1041937f63c3b495c7ed5b211b9'}\n\n```{.r .cell-code}\nfive_days_ahead <- flatline_forecaster(\n  jhu,\n  outcome = \"death_rate\",\n  flatline_args_list(ahead = 5L)\n)\n\nfive_days_ahead\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n#> ══ A basic forecaster of type flatline ══════════════════════════════════════\n#> \n#> This forecaster was fit on 2023-06-27 10:43:54\n#> \n#> Training data was an `epi_df` with\n#> • Geography: state,\n#> • Time type: day,\n#> • Using data up-to-date as of: 2022-05-31 12:08:25.\n#> \n#> ── Predictions ──────────────────────────────────────────────────────────────\n#> \n#> A total of 56 predictions are available for\n#> • 56 unique geographic regions,\n#> • At forecast dates: 2021-12-31,\n#> • For target dates: 2022-01-05.\n```\n:::\n:::\n\n\nWe could also specify that we want a 80% predictive interval by changing the \nlevels. The default 0.05 and 0.95 levels/quantiles give us 90% predictive \ninterval.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-5_04fc200f272f42d862a3c5693cc610b6'}\n\n```{.r .cell-code}\nfive_days_ahead <- flatline_forecaster(\n  jhu,\n  outcome = \"death_rate\",\n  flatline_args_list(ahead = 5L, levels = c(0.1, 0.9))\n)\n\nfive_days_ahead\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n#> ══ A basic forecaster of type flatline ══════════════════════════════════════\n#> \n#> This forecaster was fit on 2023-06-27 10:43:54\n#> \n#> Training data was an `epi_df` with\n#> • Geography: state,\n#> • Time type: day,\n#> • Using data up-to-date as of: 2022-05-31 12:08:25.\n#> \n#> ── Predictions ──────────────────────────────────────────────────────────────\n#> \n#> A total of 56 predictions are available for\n#> • 56 unique geographic regions,\n#> • At forecast dates: 2021-12-31,\n#> • For target dates: 2022-01-05.\n```\n:::\n:::\n\n\nTo see the other arguments that you may modify, please see `?flatline_args_list()`. For now, we will move on to looking at the workflow.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-6_23d12864d38c6b2fb9458907db32530f'}\n\n```{.r .cell-code}\nfive_days_ahead$epi_workflow\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> ══ Epi Workflow [trained] ═══════════════════════════════════════════════════\n#> Preprocessor: Recipe\n#> Model: linear_reg()\n#> Postprocessor: Frosting\n#> \n#> ── Preprocessor ─────────────────────────────────────────────────────────────\n#> 2 Recipe Steps\n#> \n#> • step_epi_ahead()\n#> • step_training_window()\n#> \n#> ── Model ────────────────────────────────────────────────────────────────────\n#> Flatline forecaster\n#> \n#> Predictions produced by geo_value resulting in 56 total forecasts.\n#> A total of 7112 residuals are available from the training set.\n#> \n#> ── Postprocessor ────────────────────────────────────────────────────────────\n#> 5 Frosting Layers\n#> \n#> • layer_predict()\n#> • layer_residual_quantiles()\n#> • layer_add_forecast_date()\n#> • layer_add_target_date()\n#> • layer_threshold()\n```\n:::\n:::\n\n\nThe fitted model here was based on minimal pre-processing of the data, \nestimating a flatline model, and then post-processing the results to be \nmeaningful for epidemiological tasks. To look deeper into the pre-processing, \nmodel and processing parts individually, you may use the `$` operator after `epi_workflow`. For example, let's examine the pre-processing part in more detail.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-7_7ebad54744c08badf9d3dac19334894f'}\n\n```{.r .cell-code}\nlibrary(workflows)\nextract_preprocessor(five_days_ahead$epi_workflow)\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-8_3b5f80e746b0846bc6204aa82a69e29e'}\n\n```\n#> \n#> ── Recipe ───────────────────────────────────────────────────────────────────\n#> \n#> ── Inputs\n#> Number of variables by role\n#> predictor:  3\n#> geo_value:  1\n#> raw:        1\n#> time_value: 1\n#> \n#> ── Operations\n#> • Leading: death_rate by 5\n#> • # of recent observations per key limited to:: Inf\n```\n:::\n\n\n\nUnder Operations, we can see that the pre-processing operations were to lead the\ndeath rate by 5 days (`step_epi_ahead()`) and that the \\# of recent observations\nused in the training window were not limited (in `step_training_window()` as\n`n_training = Inf` in `flatline_args_list()`). You should also see the\nmolded/pre-processed training data.\n\nFor symmetry, let's have a look at the post-processing.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-9_0808824fe21d98fc697b5f19bc27352c'}\n\n```{.r .cell-code}\nextract_frosting(five_days_ahead$epi_workflow)\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-10_72d5eb3c2909ae3ae55f4bacd445ad68'}\n\n```\n#> \n#> ── Frosting ─────────────────────────────────────────────────────────────────\n#> \n#> ── Layers\n#> • Creating predictions: \"<calculated>\"\n#> • Resampling residuals for predictive quantiles: \"<calculated>\" levels 0.1,\n#>   0.9\n#> • Adding forecast date: \"2021-12-31\"\n#> • Adding target date: \"2022-01-05\"\n#> • Thresholding predictions: dplyr::starts_with(\".pred\") to ]0, Inf)\n```\n:::\n\n\n\nThe post-processing operations in the order that were performed were to create the predictions and the predictive intervals, add the forecast and target dates and bound the predictions at zero.\n\nWe can also easily examine the predictions themselves.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-11_926c2f170768c33a5e9312e52477a59e'}\n\n```{.r .cell-code}\nfive_days_ahead$predictions\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 56 × 5\n#>   geo_value  .pred       .pred_distn forecast_date target_date\n#>   <chr>      <dbl>            <dist> <date>        <date>     \n#> 1 ak        0.0395 [0.1, 0.9]<q-rng> 2021-12-31    2022-01-05 \n#> 2 al        0.107  [0.1, 0.9]<q-rng> 2021-12-31    2022-01-05 \n#> 3 ar        0.490  [0.1, 0.9]<q-rng> 2021-12-31    2022-01-05 \n#> 4 as        0      [0.1, 0.9]<q-rng> 2021-12-31    2022-01-05 \n#> 5 az        0.608  [0.1, 0.9]<q-rng> 2021-12-31    2022-01-05 \n#> 6 ca        0.142  [0.1, 0.9]<q-rng> 2021-12-31    2022-01-05 \n#> # ℹ 50 more rows\n```\n:::\n:::\n\n\nThe results above show a distributional forecast produced using data through the end of 2021 for the January 5, 2022. A prediction for the death rate per 100K inhabitants along with a 95% predictive interval is available for every state (`geo_value`).\n\nThe figure below displays the prediction and prediction interval for three sample states: Arizona, New York, and Florida.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-12_338012827629211189d9c8b338a8fa27'}\n\n```{.r .cell-code  code-fold=\"true\"}\nsamp_geos <- c(\"az\", \"ny\", \"fl\")\n\nhist <- jhu %>%\n  filter(geo_value %in% samp_geos)\n\npreds <- five_days_ahead$predictions %>%\n  filter(geo_value %in% samp_geos) %>%\n  mutate(q = nested_quantiles(.pred_distn)) %>%\n  unnest(q) %>%\n  pivot_wider(names_from = tau, values_from = q)\n\nggplot(hist, aes(color = geo_value)) +\n  geom_line(aes(time_value, death_rate)) +\n  theme_bw() +\n  geom_errorbar(data = preds, aes(x = target_date, ymin = `0.1`, ymax = `0.9`)) +\n  geom_point(data = preds, aes(target_date, .pred)) +\n  geom_vline(data = preds, aes(xintercept = forecast_date)) +\n  scale_colour_viridis_d(name = \"\") +\n  scale_x_date(date_labels = \"%b %Y\", date_breaks = \"1 month\") +\n  facet_grid(geo_value ~ ., scales = \"free_y\") +\n  theme(legend.position = \"none\") +\n  labs(x = \"\", y = \"Incident deaths per 100K\\n inhabitants\")\n```\n\n::: {.cell-output-display}\n![](flatline-forecaster_files/figure-html/unnamed-chunk-12-1.svg){fig-align='center' width=90%}\n:::\n:::\n\n\nThe vertical black line is the forecast date. Here the forecast seems pretty reasonable based on the past observations shown. In cases where the recent past is highly predictive of the near future, a simple flatline forecast may be respectable, but in more complex situations where there is more uncertainty of what's to come, the flatline forecaster may be best relegated to being a baseline model and nothing more.\n\nTake for example what happens when we consider a wider range of target dates. That is, we will now predict for several different horizons or `ahead` values - in our case, 5 to 25 days ahead, inclusive. Since the flatline forecaster function forecasts at a single unique `ahead` value, we can use the `map()` function from `purrr` to apply the forecaster to each ahead value we want to use. Then, we row bind the list of results.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-13_7cca912cb9c507cdcc24b5736638e0bd'}\n\n```{.r .cell-code}\nout_df <- map(1:28, ~ flatline_forecaster(\n  epi_data = jhu,\n  outcome = \"death_rate\",\n  args_list = flatline_args_list(ahead = .x)\n)$predictions) %>%\n  list_rbind()\n```\n:::\n\n\nThen, we proceed as we did before. The only difference from before is that we're using `out_df` where we had `five_days_ahead$predictions`.\n\n\n::: {.cell layout-align=\"center\" hash='flatline-forecaster_cache/html/unnamed-chunk-14_1548e56fb2990349e1650fd2101d3bf7'}\n\n```{.r .cell-code  code-fold=\"true\"}\npreds <- out_df %>%\n  filter(geo_value %in% samp_geos) %>%\n  mutate(q = nested_quantiles(.pred_distn)) %>%\n  unnest(q) %>%\n  pivot_wider(names_from = tau, values_from = q)\n\nggplot(hist) +\n  geom_line(aes(time_value, death_rate)) +\n  geom_ribbon(\n    data = preds,\n    aes(x = target_date, ymin = `0.05`, ymax = `0.95`, fill = geo_value)\n  ) +\n  geom_point(data = preds, aes(target_date, .pred, colour = geo_value)) +\n  geom_vline(data = preds, aes(xintercept = forecast_date)) +\n  scale_colour_viridis_d() +\n  scale_fill_viridis_d(alpha = .4) +\n  scale_x_date(date_labels = \"%b %Y\", date_breaks = \"1 month\") +\n  scale_y_continuous(expand = expansion(c(0, .05))) +\n  facet_grid(geo_value ~ ., scales = \"free_y\") +\n  labs(x = \"\", y = \"Incident deaths per 100K\\n inhabitants\") +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](flatline-forecaster_files/figure-html/unnamed-chunk-14-1.svg){fig-align='center' width=90%}\n:::\n:::\n\n\nNow, you can really see the flat line trend in the predictions. And you may also observe that as we get further away from the forecast date, the more unnerving using a flatline prediction becomes. It feels increasingly unnatural.\n\nSo naturally the choice of forecaster relates to the time frame being considered. In general, using a flatline forecaster makes more sense for short-term forecasts than for long-term forecasts and for periods of great stability than in less stable times. Realistically, periods of great stability are rare. Moreover, in our model of choice we want to take into account more information about the past than just what happened at the most recent time point. So simple forecasters like the flatline forecaster don't cut it as actual contenders in many real-life situations. However, they are not useless, just used for a different purpose. A simple model is often used to compare a more complex model to, which is why you may have seen such a model used as a baseline in the [COVID Forecast Hub](https://covid19forecasthub.org). The following [blog post](https://delphi.cmu.edu/blog/2021/09/30/on-the-predictability-of-covid-19/#ensemble-forecast-performance) from Delphi explores the Hub's ensemble accuracy relative to such a baseline model.\n\n## What we've learned in a nutshell\n\nThough the flatline forecaster is a very basic model with limited customization, it is about as steady and predictable as a model can get. So it provides a good reference or baseline to compare more complicated models to.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
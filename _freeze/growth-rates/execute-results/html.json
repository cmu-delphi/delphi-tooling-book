{
  "hash": "c7a31477c0043e7cfa15a1c2b8f198ce",
  "result": {
    "markdown": "---\ntitle: Estimate growth rates in signals\n---\n\n\nA basic way of assessing growth in a signal is to look at its relative change\nover two neighboring time windows. The `epiprocess` package provides a function\n`growth_rate()` to compute such relative changes, as well as more sophisticated \nestimates the growth rate of a signal. We investigate this functionality in the\ncurrent vignette, applied to state-level daily reported COVID-19 cases from GA\nand PA, smoothed using a 7-day trailing average.\n\n\n\n\n\nThe example we'll examine uses built in data containing confirmed COVID-19 cases and deaths based on reports made available by the Center for Systems Science and Engineering at Johns Hopkins University. This example data ranges from Mar 1, 2020 to Dec 31, 2021, and is limited to California, Florida, Texas, New York, Georgia, and Pennsylvania, though, we'll use only part of that here.\n\n\n\n::: {.cell layout-align=\"center\" hash='growth-rates_cache/html/unnamed-chunk-2_90212a671d4734416d16fd0084bb2126'}\n\n:::\n\n\n## Growth rate basics\n\nThe growth rate of a function $f$ defined over a continuously-valued parameter\n$t$ is defined as $f'(t)/f(t)$, where $f'(t)$ is the derivative of $f$ at\n$t$. To estimate the growth rate of a signal in discrete-time (which can be\nthought of as evaluations or discretizations of an underlying function in\ncontinuous-time), we can estimate the derivative and divide by the signal value\nitself (or possibly a smoothed version of the signal value). \n\nThe `growth_rate()` function takes a sequence of underlying design points `x`\nand corresponding sequence `y` of signal values, and allows us to choose from\nthe following methods for estimating the growth rate at a given reference point\n`x0`, by setting the `method` argument: \n\n* \"rel_change\": uses $(\\bar B/\\bar A - 1) / h$, where $\\bar B$ is the average of\n  `y` over the second half of a sliding window of bandwidth `h` centered at the\n  reference point `x0`, and $\\bar A$ the average over the first half. This can \n  be seen as using a first-difference approximation to the derivative.\n* \"linear_reg\": uses the slope from a linear regression of `y` on `x` over a\n  sliding window centered at the reference point `x0`, divided by the fitted\n  value from this linear regression at `x0`.\n* \"smooth_spline\": uses the estimated derivative at `x0` from a smoothing spline\n  fit to `x` and `y`, via `stats::smooth.spline()`, divided by the fitted value\n  of the spline at `x0`.\n* \"trend_filter\": uses the estimated derivative at `x0` from polynomial trend\n  filtering (a discrete spline) fit to `x` and `y`, via\n  `genlasso::trendfilter()`, divided by the fitted value of the discrete spline\n  at `x0`.\n\nThe default in `growth_rate()` is `x0 = x`, so that it returns an estimate of\nthe growth rate at each underlying design point.  \n\n## Relative change\n\nThe default method is \"rel_change\", which is the simplest way to estimate growth\nrates. The default bandwidth is `h = 7`, which for daily data, considers the\nrelative change in a signal over adjacent weeks. We can wrap `growth_rate()` in\na call to `dplyr::mutate()` to append a new column to our `epi_df` object with\nthe computed growth rates.\n\n\n::: {.cell layout-align=\"center\" hash='growth-rates_cache/html/unnamed-chunk-3_c0f1a99e6a348f43892713c07255e1bd'}\n\n```{.r .cell-code}\nx <- x %>%\n  group_by(geo_value) %>%\n  mutate(cases_gr1 = growth_rate(time_value, cases))\n\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> An `epi_df` object, 1,158 x 4 with metadata:\n#> * geo_type  = state\n#> * time_type = day\n#> * as_of     = 2022-05-23 13:17:07\n#> \n#> # A tibble: 1,158 × 4\n#> # Groups:   geo_value [2]\n#>   geo_value time_value cases cases_gr1\n#> * <chr>     <date>     <dbl>     <dbl>\n#> 1 ga        2020-06-01  643.   0.00601\n#> 2 ga        2020-06-02  603.   0.0185 \n#> 3 ga        2020-06-03  608    0.0240 \n#> 4 ga        2020-06-04  656.   0.0218 \n#> 5 ga        2020-06-05  677.   0.0193 \n#> 6 ga        2020-06-06  718.   0.0163 \n#> # ℹ 1,152 more rows\n```\n:::\n:::\n\n\nWe can visualize these growth rate estimates by plotting the signal values and\nhighlighting the periods in time for which the relative change is above 1% (in\nred) and below -1% (in blue), faceting by geo value. \n\n\n::: {.cell layout-align=\"center\" hash='growth-rates_cache/html/unnamed-chunk-4_8c243fea3b439cbd9f00e42ee6df1596'}\n\n```{.r .cell-code  code-fold=\"true\"}\nupper <- 0.01\nlower <- -0.01\n\nggplot(x, aes(x = time_value, y = cases)) +\n  geom_tile(\n    data = x %>% filter(cases_gr1 >= upper),\n    aes(x = time_value, y = 0, width = 7, height = Inf),\n    fill = 2, alpha = 0.08\n  ) +\n  geom_tile(\n    data = x %>% filter(cases_gr1 <= lower),\n    aes(x = time_value, y = 0, width = 7, height = Inf),\n    fill = 4, alpha = 0.08\n  ) +\n  geom_line() +\n  facet_wrap(vars(geo_value), scales = \"free_y\") +\n  scale_x_date(minor_breaks = \"month\", date_labels = \"%b %Y\") +\n  scale_y_continuous(expand = expansion(c(0, 0.05))) +\n  labs(x = \"Date\", y = \"Reported COVID-19 cases\")\n```\n\n::: {.cell-output-display}\n![](growth-rates_files/figure-html/unnamed-chunk-4-1.svg){fig-align='center' width=90%}\n:::\n:::\n\n\nAs a more direct visualization, we plot the estimated growth rates themselves,\noverlaying the curves for the two states on one plot. \n\n\n::: {.cell layout-align=\"center\" hash='growth-rates_cache/html/unnamed-chunk-5_8afaf2ba22e39074da0d9093aad80bc6'}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot(x, aes(x = time_value, y = cases_gr1)) +\n  geom_line(aes(col = geo_value)) +\n  geom_hline(yintercept = upper, linetype = 2, col = 2) +\n  geom_hline(yintercept = lower, linetype = 2, col = 4) +\n  scale_color_manual(values = c(3, 6)) +\n  scale_x_date(minor_breaks = \"month\", date_labels = \"%b %Y\") +\n  labs(x = \"Date\", y = \"Growth rate\", col = \"State\")\n```\n\n::: {.cell-output-display}\n![](growth-rates_files/figure-html/unnamed-chunk-5-1.svg){fig-align='center' width=90%}\n:::\n:::\n\n\nWe can see that the estimated growth rates from the relative change method are\nsomewhat volatile, and there appears to be some bias towards towards the right\nboundary of the time span---look at the estimated growth rate for Georgia in\nlate December 2021, which takes a potentially suspicious dip. In general,\nestimation of derivatives will be difficult near the boundary, but relative\nchanges can suffer from particularly noticeable boundary bias because they are\nbased on a difference in averages over two halves of a local window, and with\nthis simplistic approach, one of these halves will be truncated near a boundary.\n\n## Linear regression\n\nThe second simplest method available is \"linear_reg\", whose default bandwidth is\nagain `h = 7`. Compared to \"rel_change\", it appears to behave similarly overall,\nbut thankfully avoids some of the troublesome spikes:\n\n\n::: {.cell layout-align=\"center\" hash='growth-rates_cache/html/unnamed-chunk-6_5f69ee2208e7ab381927baff14c5ee36'}\n\n```{.r .cell-code}\nx <- x %>%\n  group_by(geo_value) %>%\n  mutate(cases_gr2 = growth_rate(time_value, cases, method = \"linear_reg\"))\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='growth-rates_cache/html/unnamed-chunk-7_714913b51436803d947772a84bd89897'}\n\n```{.r .cell-code  code-fold=\"true\"}\nx %>%\n  pivot_longer(\n    cols = starts_with(\"cases_gr\"),\n    names_to = \"method\",\n    values_to = \"gr\"\n  ) %>%\n  mutate(\n    method = recode(method,\n      cases_gr1 = \"rel_change\",\n      cases_gr2 = \"linear_reg\"\n    )\n  ) %>%\n  ggplot(aes(x = time_value, y = gr)) +\n  geom_hline(yintercept = 0) +\n  geom_line(aes(col = method)) +\n  scale_color_manual(values = c(2, 4)) +\n  facet_wrap(vars(geo_value), scales = \"free_y\", ncol = 1) +\n  scale_x_date(minor_breaks = \"month\", date_labels = \"%b %Y\") +\n  labs(x = \"Date\", y = \"Growth rate\", col = \"Method\")\n```\n\n::: {.cell-output-display}\n![](growth-rates_files/figure-html/unnamed-chunk-7-1.svg){fig-align='center' width=90%}\n:::\n:::\n\n\n## Nonparametric estimation\n\nWe can also use a nonparametric method to estimate the derivative, through\n\"smooth_spline\" or \"trend_filter\". The latter is going to be generally more\ncomputationally expensive, but it is also able to adapt better to the local\nlevel of smoothness. (The apparent efficiency is actually compounded by the\nparticular implementations and default settings for these methods:\n\"trend_filter\" is based on a full solution path algorithm provided in the\n`genlasso` package, and performs cross-validation by default in order to pick\nthe level of regularization; read the documentation for `growth_rate()` more\ndetails.) \n\n\n::: {.cell layout-align=\"center\" hash='growth-rates_cache/html/unnamed-chunk-8_dba4540f8baa396296f1252aeeb08790'}\n\n```{.r .cell-code}\nx <- x %>%\n  group_by(geo_value) %>%\n  mutate(\n    cases_gr3 = growth_rate(time_value, cases, method = \"smooth_spline\"),\n    cases_gr4 = growth_rate(time_value, cases, method = \"trend_filter\")\n  )\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='growth-rates_cache/html/unnamed-chunk-9_26f30e9ef6062725bda13985c480fdd7'}\n\n```{.r .cell-code  code-fold=\"true\"}\nx %>%\n  select(geo_value, time_value, cases_gr3, cases_gr4) %>%\n  pivot_longer(\n    cols = starts_with(\"cases_gr\"),\n    names_to = \"method\",\n    values_to = \"gr\"\n  ) %>%\n  mutate(method = recode(method,\n    cases_gr3 = \"smooth_spline\",\n    cases_gr4 = \"trend_filter\"\n  )) %>%\n  ggplot(aes(x = time_value, y = gr)) +\n  geom_hline(yintercept = 0) +\n  geom_line(aes(col = method)) +\n  scale_color_manual(values = c(3, 6)) +\n  facet_wrap(vars(geo_value), scales = \"free_y\", ncol = 1) +\n  scale_x_date(minor_breaks = \"month\", date_labels = \"%b %Y\") +\n  labs(x = \"Date\", y = \"Growth rate\", col = \"Method\")\n```\n\n::: {.cell-output-display}\n![](growth-rates_files/figure-html/unnamed-chunk-9-1.svg){fig-align='center' width=90%}\n:::\n:::\n\n\nIn this particular example, the trend filtering estimates of growth rate appear \nto be much more stable than those from the smoothing spline, and also much more \nstable than the estimates from local relative changes and linear regressions.\n\nThe smoothing spline growth rate estimates are based on the default settings in\n`stats::smooth.spline()`, and appear severely under-regularized here. Any of the\narguments to `stats::smooth.spline()` can be customized by passing them as\nadditional arguments `...` in the call to `growth_rate()`; similarly, we can\nalso use additional arguments to customize the settings in the underlying trend\nfiltering functions `genlasso::trendfilter()`, `genlasso::cv.trendfilter()`, and\nthe documentation for `growth_rate()` gives the full details.\n\n## Log scale estimation\n\nIn general, and alternative view for the growth rate of a function $f$ is given\nby defining $g(t) = \\log(f(t))$, and then observing that $g'(t) = f'(t)/f(t)$.\nTherefore, any method that estimates the derivative can be simply applied to the\nlog of the signal of interest, and in this light, each method above \n(\"rel_change\", \"linear_reg\", \"smooth_spline\", and \"trend_filter\") has a log\nscale analog, which can be used by setting the argument `log_scale = TRUE` in\nthe call to `growth_rate()`.\n\n\n::: {.cell layout-align=\"center\" hash='growth-rates_cache/html/unnamed-chunk-10_8010b6d42bffdd224e07ee7645ccaabd'}\n\n```{.r .cell-code}\nx <- x %>%\n  group_by(geo_value) %>%\n  mutate(\n    cases_gr5 = growth_rate(time_value, cases,\n      method = \"rel_change\",\n      log_scale = TRUE\n    ),\n    cases_gr6 = growth_rate(time_value, cases,\n      method = \"linear_reg\",\n      log_scale = TRUE\n    ),\n    cases_gr7 = growth_rate(time_value, cases,\n      method = \"smooth_spline\",\n      log_scale = TRUE\n    ),\n    cases_gr8 = growth_rate(time_value, cases,\n      method = \"trend_filter\",\n      log_scale = TRUE\n    )\n  )\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='growth-rates_cache/html/unnamed-chunk-11_b6204de22436262c14a6fa081fa7e9c5'}\n\n```{.r .cell-code  code-fold=\"true\"}\nx %>%\n  select(geo_value, time_value, cases_gr5, cases_gr6) %>%\n  pivot_longer(\n    cols = starts_with(\"cases_gr\"),\n    names_to = \"method\",\n    values_to = \"gr\"\n  ) %>%\n  mutate(method = recode(method,\n    cases_gr5 = \"rel_change_log\",\n    cases_gr6 = \"linear_reg_log\"\n  )) %>%\n  ggplot(aes(x = time_value, y = gr)) +\n  geom_line(aes(col = method)) +\n  geom_hline(yintercept = 0) +\n  scale_color_manual(values = c(2, 4)) +\n  facet_wrap(vars(geo_value), scales = \"free_y\", ncol = 1) +\n  scale_x_date(minor_breaks = \"month\", date_labels = \"%b %Y\") +\n  labs(x = \"Date\", y = \"Growth rate\", col = \"Method\")\n```\n\n::: {.cell-output-display}\n![](growth-rates_files/figure-html/unnamed-chunk-11-1.svg){fig-align='center' width=90%}\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\nx %>%\n  select(geo_value, time_value, cases_gr7, cases_gr8) %>%\n  pivot_longer(\n    cols = starts_with(\"cases_gr\"),\n    names_to = \"method\",\n    values_to = \"gr\"\n  ) %>%\n  mutate(method = recode(method,\n    cases_gr7 = \"smooth_spline_log\",\n    cases_gr8 = \"trend_filter_log\"\n  )) %>%\n  ggplot(aes(x = time_value, y = gr)) +\n  geom_hline(yintercept = 0) +\n  geom_line(aes(col = method)) +\n  scale_color_manual(values = c(3, 6)) +\n  facet_wrap(vars(geo_value), scales = \"free_y\", ncol = 1) +\n  scale_x_date(minor_breaks = \"month\", date_labels = \"%b %Y\") +\n  labs(x = \"Date\", y = \"Growth rate\", col = \"Method\")\n```\n\n::: {.cell-output-display}\n![](growth-rates_files/figure-html/unnamed-chunk-11-2.svg){fig-align='center' width=90%}\n:::\n:::\n\n\nComparing the `rel_change_log` curves with their `rel_change` counterparts \n(shown in earlier figures), we see that the former curves appear less volatile \nand match the linear regression estimates much more closely. In particular, when\n`rel_change` has upward spikes, `rel_change_log` has less pronounced spikes.\nWhy does this occur? The estimate of $g'(t)$ here can be expressed as $\\mathbb\nE[\\log(B)-\\log(A)]/h = \\mathbb E[\\log(1+hR)]/h$, where $R = ((B-A)/h) / A$, and \nthe expectation refers to averaging over the $h$ observations in each window.\nConsider the following two relevant inequalities, both due to concavity of the\nlogarithm function: \n\n$$\n\\mathbb E[\\log(1+hR)]/h \\leq \\log(1+h\\mathbb E[R])/h \\leq \\mathbb E[R].\n$$\n\nThe first inequality is Jensen's; the second inequality is because the tangent \nline of a concave function lies above it. Finally, we observe that $\\mathbb\nE[R] \\approx ((\\bar B-\\bar A)/h) / \\bar A$, which the `rel_change` estimate.  \nThis explains why the `rel_change_log` curve often lies below the `rel_change`\ncurve.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
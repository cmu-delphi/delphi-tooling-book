{
  "hash": "ef06ff93fa44c25cdac272e9bf1aeb9b",
  "result": {
    "markdown": "# Getting data into epi_df format\n\n\n\n\n\nWe'll start by showing how to get data into \n`epi_df`, which is just\na tibble with a bit of special structure, and is the format assumed by all of\nthe functions in the `epiprocess` package. An `epi_df` object has (at least) the\nfollowing columns:\n\n* `geo_value`: the geographic value associated with each row of measurements.\n* `time_value`: the time value associated with each row of measurements.\n\nIt can have any number of other columns which can serve as measured variables,\nwhich we also broadly refer to as signal variables. The documentation for\n gives more details about this data format.\n\nA data frame or tibble that has `geo_value` and `time_value` columns can be\nconverted into an `epi_df` object, using the function `as_epi_df()`. As an\nexample, we'll work with daily cumulative COVID-19 cases from four U.S. states:\nCA, FL, NY, and TX, over time span from mid 2020 to early 2022, and we'll use\nthe [`epidatr`](https://github.com/cmu-delphi/epidatr) package\nto fetch this data from the [COVIDcast\nAPI](https://cmu-delphi.github.io/delphi-epidata/api/covidcast.html).\n\n\n::: {.cell layout-align=\"center\" hash='epidf_cache/html/unnamed-chunk-2_a8b0ce831d237748edcef31c420862a2'}\n\n```{.r .cell-code}\nlibrary(epidatr)\nlibrary(epiprocess)\nlibrary(withr)\n\ncases <- pub_covidcast(\n  source = \"jhu-csse\",\n  signals = \"confirmed_cumulative_num\",\n  time_type = \"day\",\n  geo_type = \"state\",\n  time_values = epirange(20200301, 20220131),\n  geo_values = \"ca,fl,ny,tx\"\n)\n\ncolnames(cases)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>  [1] \"geo_value\"           \"signal\"              \"source\"             \n#>  [4] \"geo_type\"            \"time_type\"           \"time_value\"         \n#>  [7] \"direction\"           \"issue\"               \"lag\"                \n#> [10] \"missing_value\"       \"missing_stderr\"      \"missing_sample_size\"\n#> [13] \"value\"               \"stderr\"              \"sample_size\"\n```\n:::\n:::\n\n\nAs we can see, a data frame returned by `epidatr::covidcast()` has the\ncolumns required for an `epi_df` object (along with many others). We can use\n`as_epi_df()`, with specification of some relevant metadata, to bring the data\nframe into `epi_df` format.\n\n\n::: {.cell layout-align=\"center\" hash='epidf_cache/html/unnamed-chunk-3_634293240d733bec84dd8b6a5c74e634'}\n\n```{.r .cell-code}\nx <- as_epi_df(cases,\n  geo_type = \"state\",\n  time_type = \"day\",\n  as_of = max(cases$issue)\n) %>%\n  select(geo_value, time_value, total_cases = value)\n\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"epi_df\"     \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\nsummary(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> An `epi_df` x, with metadata:\n#> * geo_type  = state\n#> * time_type = day\n#> * as_of     = 2023-03-10\n#> ----------\n#> * min time value              = 2020-03-01\n#> * max time value              = 2022-01-31\n#> * average rows per time value = 4\n```\n:::\n\n```{.r .cell-code}\nhead(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> An `epi_df` object, 6 x 3 with metadata:\n#> * geo_type  = state\n#> * time_type = day\n#> * as_of     = 2023-03-10\n#> \n#> # A tibble: 6 Ã— 3\n#>   geo_value time_value total_cases\n#> * <chr>     <date>           <dbl>\n#> 1 ca        2020-03-01          19\n#> 2 fl        2020-03-01           0\n#> 3 ny        2020-03-01           0\n#> 4 tx        2020-03-01           0\n#> 5 ca        2020-03-02          23\n#> 6 fl        2020-03-02           1\n```\n:::\n\n```{.r .cell-code}\nattributes(x)$metadata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> $geo_type\n#> [1] \"state\"\n#> \n#> $time_type\n#> [1] \"day\"\n#> \n#> $as_of\n#> [1] \"2023-03-10\"\n```\n:::\n:::\n\n\n## Some details on metadata\n\nIn general, an `epi_df` object has the following fields in its metadata:\n \n* `geo_type`: the type for the geo values.\n* `time_type`: the type for the time values.\n* `as_of`: the time value at which the given data were available.\n\nMetadata for an `epi_df` object `x` can be accessed (and altered) via\n`attributes(x)$metadata`. The first two fields here, `geo_type` and `time_type`,\nare not currently used by any downstream functions in the `epiprocess` package,\nand serve only as useful bits of information to convey about the data set at\nhand. The last field here, `as_of`, is one of the most unique aspects of an\n`epi_df` object.\n\nIn brief, we can think of an `epi_df` object as a single snapshot of a data set\nthat contains the most up-to-date values of some signals of interest, as of the\ntime specified `as_of`. For example, if `as_of` is January 31, 2022, then the\n`epi_df` object has the most up-to-date version of the data available as of\nJanuary 31, 2022. The `epiprocess` package also provides a companion data\nstructure called `epi_archive`, which stores the full version history of a given\ndata set. See the [archive\nvignette](https://cmu-delphi.github.io/epiprocess/articles/archive.html) for\nmore.\n\nIf any of the `geo_type`, `time_type`, or `as_of` arguments are missing in a \ncall to `as_epi_df()`, then this function will try to infer them from the passed\nobject. Usually, `geo_type` and `time_type` can be inferred from the `geo_value`\nand `time_value` columns, respectively, but inferring the `as_of` field is not \nas easy. See the documentation for `as_epi_df()` more details.\n\n\n::: {.cell layout-align=\"center\" hash='epidf_cache/html/unnamed-chunk-4_1c364218e936aa6527bd0675ab37d455'}\n\n```{.r .cell-code}\nx <- as_epi_df(cases) %>%\n  select(geo_value, time_value, total_cases = value)\n\nattributes(x)$metadata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> $geo_type\n#> [1] \"state\"\n#> \n#> $time_type\n#> [1] \"day\"\n#> \n#> $as_of\n#> [1] \"2023-03-10\"\n```\n:::\n:::\n\n\n## Using additional key columns in `epi_df` {#sec-additional-keys}\n\nIn the following examples we will show how to create an `epi_df` with additional keys.\n\n### Converting a `tsibble` that has county code as an extra key\n\n\n::: {.cell layout-align=\"center\" hash='epidf_cache/html/unnamed-chunk-5_28361d3ac565b78677e217c86faf03cc'}\n\n```{.r .cell-code}\nset.seed(12345)\nex1 <- tibble(\n  geo_value = rep(c(\"ca\", \"fl\", \"pa\"), each = 3),\n  county_code = c(\n    \"06059\", \"06061\", \"06067\", \"12111\", \"12113\", \"12117\",\n    \"42101\", \"42103\", \"42105\"\n  ),\n  time_value = rep(\n    seq(as.Date(\"2020-06-01\"), as.Date(\"2020-06-03\"), by = \"1 day\"),\n    length.out = 9\n  ),\n  value = rpois(9, 5)\n) %>%\n  as_tsibble(index = time_value, key = c(geo_value, county_code))\n\nex1 <- as_epi_df(x = ex1, geo_type = \"state\", time_type = \"day\", as_of = \"2020-06-03\")\n```\n:::\n\n\nThe metadata now includes `county_code` as an extra key.\n\n::: {.cell layout-align=\"center\" hash='epidf_cache/html/unnamed-chunk-6_1c760ce7c25a1f6867568618118bb7ac'}\n\n```{.r .cell-code}\nattr(ex1, \"metadata\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> $geo_type\n#> [1] \"state\"\n#> \n#> $time_type\n#> [1] \"day\"\n#> \n#> $as_of\n#> [1] \"2020-06-03\"\n#> \n#> $other_keys\n#> [1] \"county_code\"\n```\n:::\n:::\n\n\n\n### Dealing with misspecified column names \n\n`epi_df` requires there to be columns `geo_value` and `time_value`, if they do not exist then `as_epi_df()` throws an error.\n\n\n::: {.cell layout-align=\"center\" hash='epidf_cache/html/unnamed-chunk-7_52307fa1e07fa21173de3e9416897483'}\n\n```{.r .cell-code}\nex2 <- data.frame(\n  state = rep(c(\"ca\", \"fl\", \"pa\"), each = 3), # misnamed\n  pol = rep(c(\"blue\", \"swing\", \"swing\"), each = 3), # extra key\n  reported_date = rep(\n    seq(as.Date(\"2020-06-01\"), as.Date(\"2020-06-03\"), by = \"day\"),\n    length.out = 9\n  ), # misnamed\n  value = rpois(9, 5)\n)\nex2 %>% as_epi_df()\n```\n\n::: {.cell-output .cell-output-error}\n```\n#> Error in `Abort()`:\n#> ! `x` must contain a `geo_value` column.\n```\n:::\n:::\n\n\nThe columns should be renamed to match `epi_df` format. \n\n\n::: {.cell layout-align=\"center\" hash='epidf_cache/html/unnamed-chunk-8_eea2403289899a6533606cf4f555d400'}\n\n```{.r .cell-code}\nex2 <- ex2 %>%\n  rename(geo_value = state, time_value = reported_date) %>%\n  as_epi_df(\n    geo_type = \"state\",\n    as_of = \"2020-06-03\",\n    additional_metadata = list(other_keys = \"pol\")\n  )\n\nattr(ex2, \"metadata\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> $geo_type\n#> [1] \"state\"\n#> \n#> $time_type\n#> [1] \"day\"\n#> \n#> $as_of\n#> [1] \"2020-06-03\"\n#> \n#> $other_keys\n#> [1] \"pol\"\n```\n:::\n:::\n\n\n\n### Adding additional keys to an `epi_df` object\n\nIn the above examples, all the keys are added to objects prior to conversion to\n`epi_df` objects. But this can also be accomplished afterward.\nWe'll look at an included dataset and filter to a single state for simplicity.\n\n\n::: {.cell layout-align=\"center\" hash='epidf_cache/html/unnamed-chunk-9_fc0625e5160d2a01eb47d18c346874ed'}\n\n```{.r .cell-code}\nex3 <- jhu_csse_county_level_subset %>%\n  filter(time_value > \"2021-12-01\", state_name == \"Massachusetts\") %>%\n  slice_tail(n = 6)\n\nattr(ex3, \"metadata\") # geo_type is county currently\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> $geo_type\n#> [1] \"county\"\n#> \n#> $time_type\n#> [1] \"day\"\n#> \n#> $as_of\n#> [1] \"2022-05-23 14:35:45 PDT\"\n```\n:::\n:::\n\n\nNow we add `state` (MA) and `pol` as new columns to the data and as new keys to the metadata. The \"state\" `geo_type` anticipates lower-case abbreviations, so we'll match that. \n\n\n::: {.cell layout-align=\"center\" hash='epidf_cache/html/unnamed-chunk-10_fe2c6e15016b44b9220d5fc4f6b51049'}\n\n```{.r .cell-code}\nex3 <- ex3 %>%\n  as_tibble() %>% # drop the `epi_df` class before adding additional metadata\n  mutate(\n    state = rep(tolower(\"MA\"), 6),\n    pol = rep(c(\"blue\", \"swing\", \"swing\"), each = 2)\n  ) %>%\n  as_epi_df(additional_metadata = list(other_keys = c(\"state\", \"pol\")))\n\nattr(ex3, \"metadata\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> $geo_type\n#> [1] \"county\"\n#> \n#> $time_type\n#> [1] \"day\"\n#> \n#> $as_of\n#> [1] \"2023-12-15 04:50:49 PST\"\n#> \n#> $other_keys\n#> [1] \"state\" \"pol\"\n```\n:::\n:::\n\n\nNote that the two additional keys we added, `state` and `pol`, are specified as a character vector in the `other_keys` component of the `additional_metadata` list. They must be specified in this manner so that downstream actions on the `epi_df`, like model fitting and prediction, can recognize and use these keys.\n\n<!--\nCurrently `other_keys` metadata in `epi_df` doesn't impact `epi_slide()`, contrary to `other_keys` in `as_epi_archive` which affects how the update data is interpreted.\n-->\n\n## Working with `epi_df` objects downstream\n\nData in `epi_df` format should be easy to work with downstream, since it is a\nvery standard tabular data format; in the other vignettes, we'll walk through\nsome basic signal processing tasks using functions provided in the `epiprocess`\npackage. Of course, we can also write custom code for other downstream uses,\nlike plotting, which is pretty easy to do `ggplot2`.\n\n\n::: {.cell layout-align=\"center\" hash='epidf_cache/html/unnamed-chunk-11_cf02eb699138d3d8365b66804d295fde'}\n\n```{.r .cell-code}\nggplot(x, aes(x = time_value, y = total_cases, color = geo_value)) +\n  geom_line() +\n  scale_color_brewer(palette = \"Set1\") +\n  scale_x_date(minor_breaks = \"month\", date_labels = \"%b %Y\") +\n  labs(x = \"Date\", y = \"Cumulative COVID-19 cases\", color = \"State\")\n```\n\n::: {.cell-output-display}\n![](epidf_files/figure-html/unnamed-chunk-11-1.svg){fig-align='center' width=90%}\n:::\n:::\n\n\nFinally, we'll examine some data from other packages just to show how \nwe might get them into `epi_df` format. \nThe first is data on daily new (not cumulative) SARS \ncases in Canada in 2003, from the \n[outbreaks](https://github.com/reconverse/outbreaks) package. New cases are\nbroken into a few categories by provenance.\n\n\n::: {.cell layout-align=\"center\" hash='epidf_cache/html/unnamed-chunk-12_f4dc254695766edbb2625b67c42932b7'}\n\n```{.r .cell-code}\nx <- outbreaks::sars_canada_2003 %>%\n  mutate(geo_value = \"ca\") %>%\n  select(geo_value, time_value = date, starts_with(\"cases\")) %>%\n  as_epi_df(geo_type = \"nation\")\n\nhead(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> An `epi_df` object, 6 x 6 with metadata:\n#> * geo_type  = nation\n#> * time_type = day\n#> * as_of     = 2023-12-15 04:50:50\n#> \n#> # A tibble: 6 Ã— 6\n#>   geo_value time_value cases_travel cases_household cases_healthcare\n#> * <chr>     <date>            <int>           <int>            <int>\n#> 1 ca        2003-02-23            1               0                0\n#> 2 ca        2003-02-24            0               0                0\n#> 3 ca        2003-02-25            0               0                0\n#> 4 ca        2003-02-26            0               1                0\n#> 5 ca        2003-02-27            0               0                0\n#> 6 ca        2003-02-28            1               0                0\n#> # â„¹ 1 more variable: cases_other <int>\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\" hash='epidf_cache/html/unnamed-chunk-13_af68bf6df70c76b27435c6f2822266e9'}\n\n```{.r .cell-code  code-fold=\"true\"}\nx <- x %>%\n  pivot_longer(starts_with(\"cases\"), names_to = \"type\") %>%\n  mutate(type = substring(type, 7))\n\nggplot(x, aes(x = time_value, y = value)) +\n  geom_col(aes(fill = type), just = 0.5) +\n  scale_y_continuous(breaks = 0:4 * 2, expand = expansion(c(0, 0.05))) +\n  scale_x_date(minor_breaks = \"month\", date_labels = \"%b %Y\") +\n  labs(x = \"Date\", y = \"SARS cases in Canada\", fill = \"Type\")\n```\n\n::: {.cell-output-display}\n![](epidf_files/figure-html/unnamed-chunk-13-1.svg){fig-align='center' width=90%}\n:::\n:::\n\n\nThis next example examines data on new cases of Ebola in Sierra Leone in 2014 (from the same package).\n\n\n::: {.cell layout-align=\"center\" hash='epidf_cache/html/unnamed-chunk-14_09c7102254a1a233a78be842fcaf2096'}\n\n```{.r .cell-code}\nx <- outbreaks::ebola_sierraleone_2014 %>%\n  mutate(\n    cases = ifelse(status == \"confirmed\", 1, 0),\n    province = case_when(\n      district %in% c(\"Kailahun\", \"Kenema\", \"Kono\") ~ \"Eastern\",\n      district %in% c(\n        \"Bombali\", \"Kambia\", \"Koinadugu\",\n        \"Port Loko\", \"Tonkolili\"\n      ) ~ \"Northern\",\n      district %in% c(\"Bo\", \"Bonthe\", \"Moyamba\", \"Pujehun\") ~ \"Sourthern\",\n      district %in% c(\"Western Rural\", \"Western Urban\") ~ \"Western\"\n    )\n  ) %>%\n  select(geo_value = province, time_value = date_of_onset, cases) %>%\n  filter(cases == 1) %>%\n  group_by(geo_value, time_value) %>%\n  summarise(cases = sum(cases)) %>%\n  as_epi_df(geo_type = \"province\")\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='epidf_cache/html/unnamed-chunk-15_7b787f995e155e919b8f184101e75f87'}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot(x, aes(x = time_value, y = cases)) +\n  geom_col(aes(fill = geo_value), show.legend = FALSE) +\n  facet_wrap(~geo_value, scales = \"free_y\") +\n  scale_x_date(minor_breaks = \"month\", date_labels = \"%b %Y\") +\n  labs(x = \"Date\", y = \"Confirmed cases of Ebola in Sierra Leone\")\n```\n\n::: {.cell-output-display}\n![](epidf_files/figure-html/unnamed-chunk-15-1.svg){fig-align='center' width=90%}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
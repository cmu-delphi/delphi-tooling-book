{
  "hash": "7ee32c5ba1c0989372740ec26327360f",
  "result": {
    "markdown": "# Regression in Tidymodels - Part 2\n\nThis chapter is starts off as the Regression in Tidymodels chapter - Epidemiological time series edition and goes from there to making (slightly) more sophisticated predictions and interactive plots.\n\n\n::: {.cell}\n\n:::\n\n\n## Libraries and data\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-2_2c39d10eba215aedfac490542d500110'}\n\n```{.r .cell-code}\n# Load necessary packages\nlibrary(tidymodels)\nlibrary(plotly)\n```\n:::\n\n\nAs a follow-up to the Regression in `Tidymodels` chapter, we're going to look at how the functions we used to perform linear regression fair when applied to a small set of epidemiological time series data. We'll be working with the built-in data on daily confirmed COVID-19 case and death rates for California over Dec. 31, 2020 to Dec. 31, 2021 (this was originally compiled by JHU).\n\nNote that while data is available for all states, we're focusing on just one state's worth of data to avoid having to manage multiple regions (panel data) just yet. \n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-3_285a3f7cc79d33f0328599de942fcaa4'}\n\n```{.r .cell-code}\n# Load and subset data\nca_case_death_rate_subset <- case_death_rate_subset %>%\n  filter(geo_value == \"ca\")\n```\n:::\n\n\n## Simple linear regression\n\nOur goal for this exercise is to construct a simple linear regression model of daily death rate as a function of daily case rate. And to do this, we'll essentially work through the same routine that we went through above (just in a different scenario). Thus, we'll opt for the same linear regression model specification. As we mentioned previously, setting the mode is unnecessary for linear regression, so let's drop that bit this time round. In addition, `lm` is the default engine for linear regression, so, we don't have to include that bit either.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-4_9d2c534c117001f34f0ffec4c97ca8ee'}\n::: {.cell-output-display}\n![](img/set_engine.png){fig-align='center' width=50%}\n:::\n:::\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-5_c8e1a2301b605fd10d31d77d5991e127'}\n\n```{.r .cell-code}\nlm_spec_way2 <- linear_reg()\n```\n:::\n\n\nNow we fit our model by inputting the formula (of the form `y ~ x`) `death_rate ~ case_rate` and the `ca_case_death_rate_subset` into the `fit()` function.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-6_d07c113145028a505520eff20bc12b90'}\n\n```{.r .cell-code}\nca_lm_fit <- lm_spec_way2 %>%\n  fit(death_rate ~ case_rate, data = ca_case_death_rate_subset)\nca_lm_fit\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> parsnip model object\n#> \n#> \n#> Call:\n#> stats::lm(formula = death_rate ~ case_rate, data = data)\n#> \n#> Coefficients:\n#> (Intercept)    case_rate  \n#>    0.158168     0.009175\n```\n:::\n:::\n\n\nAs before, let's use `purrr`’s `pluck()` function to access the underlying fit and then pipe that into `summary()` to get a basic synopsis of our model.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-7_c75b0213d815c274ab67c3fa1cb68811'}\n\n```{.r .cell-code}\nca_lm_fit %>%\n  pluck(\"fit\") %>%\n  summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n#> Call:\n#> stats::lm(formula = death_rate ~ case_rate, data = data)\n#> \n#> Residuals:\n#>      Min       1Q   Median       3Q      Max \n#> -0.79039 -0.14212 -0.07560  0.02259  0.87239 \n#> \n#> Coefficients:\n#>              Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept) 0.1581681  0.0213029   7.425 8.09e-13 ***\n#> case_rate   0.0091755  0.0006504  14.107  < 2e-16 ***\n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> Residual standard error: 0.3021 on 364 degrees of freedom\n#> Multiple R-squared:  0.3535,\tAdjusted R-squared:  0.3517 \n#> F-statistic:   199 on 1 and 364 DF,  p-value: < 2.2e-16\n```\n:::\n:::\n\n\nNow let's forge ahead and get some predictions for the existing dataset. \n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-8_aa8fab980d307cfa71a1213383688695'}\n\n```{.r .cell-code}\npredict(ca_lm_fit, new_data = ca_case_death_rate_subset)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 366 × 1\n#>   .pred\n#>   <dbl>\n#> 1  1.04\n#> 2  1.12\n#> 3  1.10\n#> 4  1.09\n#> 5  1.09\n#> 6  1.09\n#> # ℹ 360 more rows\n```\n:::\n:::\n\n\nAnd to get a side-by-side view of the observed and predicted values (which sets us up well to compare them), we'll use `augment()`.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-9_a16c95fbd9e3ef41769d07e6f19f39e9'}\n\n```{.r .cell-code}\n# adjoin the model predictions to `ca_case_death_rate_subset`).\naugment(ca_lm_fit, new_data = ca_case_death_rate_subset) %>%\n  select(death_rate, .pred)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 366 × 2\n#>   death_rate .pred\n#>        <dbl> <dbl>\n#> 1      0.751  1.04\n#> 2      0.850  1.12\n#> 3      0.857  1.10\n#> 4      0.860  1.09\n#> 5      0.911  1.09\n#> 6      0.908  1.09\n#> # ℹ 360 more rows\n```\n:::\n:::\n\n\nAll in all, everything that we did before seems to translate seamlessly over to handling a bit of epidemiological time series data. But realistically, if we're tasked with predicting COVID-19 deaths, do we only want to look to the concurrent (same-day) case information? Or should we look into the past as well? Since what happened in the past can inform us where things are heading, we could also include case rates and death rates as predictors.\n\n## Adding lagged predictors and predicting a sliver of the future\n\nNow the big question is how far back in the past should we look? More specifically, what past case and death rates are most predictive of current deaths. This is a natural question to have at this point, but it ventures into model selection territory which beyond the scope of this article. For those interested, a lagged correlation analysis as described in the [Correlate signals over space and time chapter](correlations.qmd) is one way to start exploring this. So read it if you dare (or if you have the time).\n\nTo start, we will add predictors for the lagged 1-day death and case rates as those seem to be perhaps the most sensible choices (because yesterday is generally more predictive of today than two weeks ago would be).\n\nSo first, let's add a column for the lagged 1-day death rates by using `dplyr`'s `mutate()` function.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-10_a109c0cce6077fa034dfa6482d916f26'}\n\n```{.r .cell-code}\nca_subset_wlag <- ca_case_death_rate_subset %>%\n  mutate(lag_1_death_rate = lag(death_rate, 1))\n```\n:::\n\n\nThen, we can go ahead and create our recipe, and we can add a `lag_1_day_case_rate` column in the same way as we added a non-linear transformation of a predictor before, by using `step_mutate()` on the predictor that's been specified in the recipe formula.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-11_fcbd0b889567108db17d97a251f4394f'}\n\n```{.r .cell-code}\nrec_spec_lag <- recipe(death_rate ~ case_rate + lag_1_death_rate, data = ca_subset_wlag) %>%\n  step_mutate(lag_1_case_rate = lag(case_rate, 1))\n```\n:::\n\n\nNow, we just pop the model and recipe into our workflow and then fit the model to our dataset in the same way as we did before.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-12_d034bd6f77589f3ee04a81e46a60dcd5'}\n\n```{.r .cell-code}\nlm_wf_lag <- workflow() %>%\n  add_model(lm_spec_way2) %>%\n  add_recipe(rec_spec_lag)\n\nca_lm_fit_lag <- lm_wf_lag %>% fit(ca_subset_wlag)\nca_lm_fit_lag\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> ══ Workflow [trained] ═══════════════════════════════════════════════════════\n#> Preprocessor: Recipe\n#> Model: linear_reg()\n#> \n#> ── Preprocessor ─────────────────────────────────────────────────────────────\n#> 1 Recipe Step\n#> \n#> • step_mutate()\n#> \n#> ── Model ────────────────────────────────────────────────────────────────────\n#> \n#> Call:\n#> stats::lm(formula = ..y ~ ., data = data)\n#> \n#> Coefficients:\n#>      (Intercept)         case_rate  lag_1_death_rate   lag_1_case_rate  \n#>       -0.0040422         0.0013087         0.9793506        -0.0008568\n```\n:::\n:::\n\n\nAnd viola, we got ourselves a trained workflow - which to be clear has undergone both pre-processing (`step_mutate` to add the 1-day lagged case rate as a predictor) and model fitting. \n\nNow we'll try to use our model to predict the death rate for a day beyond the last in the dataset (so our target date is Jan. 1, 2022). Suppose that a reliable source tells us that the case rate for that day is 84.7 (cases per 100,000 population). From the last row of our dataset, we can see that the lagged 1-day case rate is about 84.4 and the lagged death rate is about 0.142 (deaths per 100,000 population). So we'll throw this info. in a short dataframe and feed it into `new_data`.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-13_e83e7a002d9bbaaec824dca5be879089'}\n\n```{.r .cell-code}\nlast_row_ca <- ca_case_death_rate_subset %>% tail(n = 1)\n\npredict(ca_lm_fit_lag, new_data = data.frame(\n  case_rate = 84.7,\n  lag_1_death_rate = last_row_ca$death_rate,\n  lag_1_case_rate = last_row_ca$case_rate\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 1 × 1\n#>   .pred\n#>   <dbl>\n#> 1    NA\n```\n:::\n:::\n\n\nHold up... Why is our prediction NA? We inputted the necessary data with the correct variable names (no typos there). So what went wrong? The answer is two paragraphs above. And here it is: Recall that we used `step_mutate` to dynamically add the lagged case rate variable as a predictor. It was not part of the original model specification. So this means that we do not want to designate a variable `lag_1_case_rate`, rather we just need enough rows of data in `new_data` so that when it undergoes the pre-processing step, that step can reach back to grab the lagged 1-day case rate from the `case_rate` variable. This is a bit of a pain, but so be it. The quick and dirty fix is to simply change `n = 1` to 2 in `tail()`, but let's flex our skills with `bind_rows()` instead.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-14_bc7c5328ace16c27fd53eb0610be2f1f'}\n\n```{.r .cell-code}\n# Add new row of to ca_case_death_rate_subset\nca_subset_plus_row <- bind_rows(\n  ca_case_death_rate_subset,\n  data.frame(\n    geo_value = \"ca\",\n    time_value = as.Date(\"2022-01-01\"),\n    case_rate = 84.7,\n    lag_1_death_rate = last_row_ca$death_rate\n  )\n)\n```\n:::\n\n\nAnd then pop that into predict...\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-15_1ab4d7dbf51419f8ddf299c5062e5c79'}\n\n```{.r .cell-code}\npredict(ca_lm_fit_lag, new_data = ca_subset_plus_row) %>%\n  tail(n = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 1 × 1\n#>   .pred\n#>   <dbl>\n#> 1 0.173\n```\n:::\n:::\n\n\nWonderful. We got ourselves a prediction. But that was a heck of a lot of work to get here. How could we simplify things for ourselves? Well there's a couple things that `epipredict` offers that could help us out here. \n\n### Option 1 - manually create our own `epi_recipe`\n\nInstead of using a plain old recipe, it is more advantageous to use an `epi_recipe` on an `epi_df`. Why? It unlocks a number of features specific to epidemiological data such as tailored pre-processing steps like creating columns of lagged data. So, instead of using the `mutate()` and `step_mutate()` combo above to get the lagged case and death rate variables, we can simply write the following where we use `step_epi_lag` to lag the predictors and specify how far ahead we want to predict the outcome using `step_epi_ahead`.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-16_e2a37e8f587941899cfb661c9593a47a'}\n\n```{.r .cell-code}\nca_epi_r <- epi_recipe(ca_case_death_rate_subset) %>%\n  step_epi_lag(case_rate, lag = c(0, 1)) %>%\n  step_epi_lag(death_rate, lag = 1) %>%\n  step_epi_ahead(death_rate, ahead = 0)\n```\n:::\n\n\nThen, just throw the `epi_recipe` into an `epi_workflow()`, fit the linear model, and predict in the same way as before.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-17_26578b49ef4da25d864cd088f8349259'}\n\n```{.r .cell-code}\nca_epi_wf <- epi_workflow(ca_epi_r, lm_spec_way2) %>%\n  fit(ca_case_death_rate_subset)\n\npredict(ca_epi_wf, ca_subset_plus_row %>% select(-lag_1_death_rate)) %>%\n  filter(time_value == \"2022-01-01\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> An `epi_df` object, 1 x 3 with metadata:\n#> * geo_type  = state\n#> * time_type = day\n#> * as_of     = 2022-05-31 12:08:25.791826\n#> \n#> # A tibble: 1 × 3\n#>   geo_value time_value .pred\n#> * <chr>     <date>     <dbl>\n#> 1 ca        2022-01-01 0.173\n```\n:::\n:::\n\n\nNotice we get the same prediction as before, just as we'd expect.\n\n### Option 2 - let the `arx_forecaster()` do the work for us\n\nWe can take things a notch further because the `epipredict` package has the `arx_forecaster()` function to make our lives easier by pre-processing, training the model, predicting, and performing some basic post-processing, all in one go. The reason why we can use this model is that the above is a technically a type of autoregressive (AR) model, in which a linear combination of previous values are use forecast the variable of interest. In contrast, in a multiple linear regression model, we use a linear combination of predictors to forecast the variable we're interested in.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-18_87146e4ff6e311476c6feb27e5127719'}\n\n```{.r .cell-code}\nca_arx_pred_jan_22 <- arx_forecaster(\n  ca_subset_plus_row %>% select(-lag_1_death_rate),\n  outcome = \"death_rate\",\n  predictors = c(\"death_rate\", \"case_rate\"),\n  args_list = arx_args_list(\n    lags = list(death_rate = c(1), case_rate = c(0, 1)),\n    ahead = 0L\n  )\n)\nca_arx_pred_jan_22$predictions\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 1 × 5\n#>   geo_value .pred         .pred_distn forecast_date target_date\n#>   <chr>     <dbl>              <dist> <date>        <date>     \n#> 1 ca        0.173 [0.05, 0.95]<q-rng> 2022-01-01    2022-01-01\n```\n:::\n:::\n\n\nWe could easily add more lags for the case and death rates into the function . All that we got to do is add a couple of choice numbers to the `lags` argument. This is infinitely preferable to the (longwinded) alternative of adding them one by one to `step_mutate()`. So let's go ahead and try adding various lags for each of case and death rate to `arx_forecaster()`:\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-19_a71bf5dcf8b9a859dc6f0736cbd53241'}\n\n```{.r .cell-code}\nlots_of_lags_ca <- arx_forecaster(\n  ca_subset_plus_row %>% select(-lag_1_death_rate),\n  outcome = \"death_rate\",\n  predictors = c(\"case_rate\", \"death_rate\"),\n  args_list = arx_args_list(\n    lags = list(case_rate = c(0, 1, 2, 3, 4, 7), death_rate = c(1, 2, 3, 4, 7)),\n    ahead = 0L\n  )\n)\nlots_of_lags_ca$predictions\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 1 × 5\n#>   geo_value .pred         .pred_distn forecast_date target_date\n#>   <chr>     <dbl>              <dist> <date>        <date>     \n#> 1 ca        0.106 [0.05, 0.95]<q-rng> 2022-01-01    2022-01-01\n```\n:::\n:::\n\n\nThe other major benefit of the above forecaster is that it is equipped to handle panel data. That means that for our example we could input several other states worth of data, and get a prediction for each state. For example, we can try plugging in the entirety of the original `case_death_rate_subset` and get a prediction of the death rate on Jan. 1, 2022 for each state. \n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-20_d6fbfbec04c3b860c6788bbf25e7b600'}\n\n```{.r .cell-code}\nall_the_states <- arx_forecaster(\n  case_death_rate_subset,\n  outcome = \"death_rate\",\n  predictors = c(\"case_rate\", \"death_rate\"),\n  args_list = arx_args_list(\n    lags = list(c(0, 1, 2, 3, 4, 7), c(1, 2, 3, 4, 7)),\n    ahead = 1L\n  )\n)\nall_the_states$predictions\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 56 × 5\n#>   geo_value   .pred         .pred_distn forecast_date target_date\n#>   <chr>       <dbl>              <dist> <date>        <date>     \n#> 1 ak        0       [0.05, 0.95]<q-rng> 2021-12-31    2022-01-01 \n#> 2 al        0.197   [0.05, 0.95]<q-rng> 2021-12-31    2022-01-01 \n#> 3 ar        0.513   [0.05, 0.95]<q-rng> 2021-12-31    2022-01-01 \n#> 4 as        0.00896 [0.05, 0.95]<q-rng> 2021-12-31    2022-01-01 \n#> 5 az        0.603   [0.05, 0.95]<q-rng> 2021-12-31    2022-01-01 \n#> 6 ca        0.192   [0.05, 0.95]<q-rng> 2021-12-31    2022-01-01 \n#> # ℹ 50 more rows\n```\n:::\n:::\n\n\nNeat! We'll learn more about this and other forecasters in later chapters.\n\n## Interactive plot of predictions\n\nLet's finish off by producing an interactive `plotly` choropleth map of our above predictions (along with the 90% predictive intervals) to get a sense of how they may be geospatially related.\n\nFirst we'll ready our data. The key part is the extraction of the quantiles that make up the 90% predictive intervals. These are by default contained inside a distribution (`.pred_distn`) which we must unnest to get to.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-21_fab146b9a2df02676de7ded1301578cd'}\n\n```{.r .cell-code}\n# Rename df of predictions to shorten up\nall_the_states_df <- all_the_states$predictions\n\n# Extract nested quantiles\nall_the_states_df <- all_the_states_df %>%\n  mutate(q = nested_quantiles(.pred_distn)) %>%\n  unnest(q) %>%\n  pivot_wider(names_from = tau, values_from = q)\n```\n:::\n\n\nThen, we simply adapted the \"Customize choropleth code\" from the [plotly website](https://plotly.com/r/choropleth-maps/) to our data. The major changes are that we specified what we would like to show when we hover (the predictions and the corresponding 90% predictive interval). As well, we modified the trace (a trace is just a layer to add to the plot with its own data and visualization components), so that the predictions determine the colour of the state and the locations are based on the state abbreviations in `geo_value`.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-22_39e447856a7ca6e1873a7e60b6edba78'}\n\n```{.r .cell-code  code-fold=\"true\"}\n# See on hover\nall_the_states_df$hover <- with(\n  all_the_states_df,\n  paste(\n    toupper(geo_value), \"<br>\",\n    \"Pred death rate:\", round(.pred, digits = 3), \"<br>\",\n    \"90% pred distn:\", paste(round(`0.05`, digits = 3),\n      round(`0.95`, digits = 3),\n      sep = \", \"\n    )\n  )\n)\n\n# Give state boundaries a white border\nl <- list(color = toRGB(\"white\"), width = 2)\n\n# Specify some map projection/options\ng <- list(\n  scope = \"usa\",\n  projection = list(type = \"albers usa\"),\n  showlakes = TRUE,\n  lakecolor = toRGB(\"white\")\n)\n\nfig <- plot_geo(all_the_states_df, locationmode = \"USA-states\")\nfig <- fig %>% add_trace(\n  z = ~.pred, text = ~hover, hoverinfo = \"text\", locations = ~ toupper(geo_value),\n  color = ~.pred, colors = \"Purples\"\n)\n\n# Add titles and such\nfig <- fig %>% colorbar(title = \"Death rate\")\nfig <- fig %>% layout(\n  title = \"2022-01-01 predicted death rate (per 100,000) by state<br>(Hover for breakdown)\",\n  geo = g\n)\n\nfig\n```\n\n::: {.cell-output-display}\n```{=html}\n<div class=\"plotly html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-47f11ee08e16179b1b17\" style=\"width:90%;height:525px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-47f11ee08e16179b1b17\">{\"x\":{\"visdat\":{\"6a547e2deb68\":[\"function () \",\"plotlyVisDat\"]},\"cur_data\":\"6a547e2deb68\",\"attrs\":{\"6a547e2deb68\":{\"locationmode\":\"USA-states\",\"alpha_stroke\":1,\"sizes\":[10,100],\"spans\":[1,20],\"z\":{},\"text\":{},\"hoverinfo\":\"text\",\"locations\":{},\"color\":{},\"colors\":\"Purples\",\"inherit\":true}},\"layout\":{\"margin\":{\"b\":40,\"l\":60,\"t\":25,\"r\":10},\"mapType\":\"geo\",\"scene\":{\"zaxis\":{\"title\":\".pred\"}},\"geo\":{\"domain\":{\"x\":[0,1],\"y\":[0,1]},\"scope\":\"usa\",\"projection\":{\"type\":\"albers usa\"},\"showlakes\":true,\"lakecolor\":\"rgba(255,255,255,1)\"},\"hovermode\":\"closest\",\"showlegend\":false,\"legend\":{\"yanchor\":\"top\",\"y\":0.5},\"title\":\"2022-01-01 predicted death rate (per 100,000) by state<br>(Hover for breakdown)\"},\"source\":\"A\",\"config\":{\"modeBarButtonsToAdd\":[\"hoverclosest\",\"hovercompare\"],\"showSendToCloud\":false},\"data\":[{\"colorbar\":{\"title\":\"Death rate\",\"ticklen\":2,\"len\":0.5,\"lenmode\":\"fraction\",\"y\":1,\"yanchor\":\"top\"},\"colorscale\":[[\"0\",\"rgba(252,251,253,1)\"],[\"0.0416666666666667\",\"rgba(248,246,250,1)\"],[\"0.0833333333333333\",\"rgba(243,242,248,1)\"],[\"0.125\",\"rgba(239,237,245,1)\"],[\"0.166666666666667\",\"rgba(232,231,242,1)\"],[\"0.208333333333333\",\"rgba(225,224,238,1)\"],[\"0.25\",\"rgba(218,218,235,1)\"],[\"0.291666666666667\",\"rgba(208,208,230,1)\"],[\"0.333333333333333\",\"rgba(198,199,225,1)\"],[\"0.375\",\"rgba(188,189,220,1)\"],[\"0.416666666666667\",\"rgba(178,177,213,1)\"],[\"0.458333333333333\",\"rgba(168,166,207,1)\"],[\"0.5\",\"rgba(158,154,200,1)\"],[\"0.541666666666667\",\"rgba(148,144,195,1)\"],[\"0.583333333333333\",\"rgba(138,135,191,1)\"],[\"0.625\",\"rgba(128,125,186,1)\"],[\"0.666666666666667\",\"rgba(121,110,178,1)\"],[\"0.708333333333333\",\"rgba(114,96,171,1)\"],[\"0.75\",\"rgba(106,81,163,1)\"],[\"0.791666666666667\",\"rgba(99,67,156,1)\"],[\"0.833333333333333\",\"rgba(92,54,150,1)\"],[\"0.875\",\"rgba(84,39,143,1)\"],[\"0.916666666666667\",\"rgba(77,28,137,1)\"],[\"0.958333333333333\",\"rgba(70,16,131,1)\"],[\"1\",\"rgba(63,0,125,1)\"]],\"showscale\":true,\"locationmode\":\"USA-states\",\"z\":[0,0.19712415389427237,0.51323231200034791,0.0089591812072605699,0.60311520646957695,0.19173956982740087,0.50332222593926335,0.42172131651829653,0.33404200726066013,0.59986038752055704,0.2657191901369545,0.40429344826234903,0.016775762317119604,0.23559684333822983,0.29538261507754571,0.41878925079680412,0.52099171405327749,0.68140468208149052,0.27867671018593088,0.56365659025312653,0.11600977546358786,0.59928619604072042,1.2639073955822999,0.65820588345020226,0.84324878078505539,0.53405334805134452,0.49744841587605432,1.2914786888552994,0.24479784126761184,0.12989447169306448,0.28678925162815616,0.30407826707219554,0.19196578820009205,0.87362717248851818,0.5162795255170004,0.66545426961470688,0.26186428511908411,0.62875934703172298,1.1160846280670333,0.29723050200099393,0.17753469722216142,0.79547856604253253,0.21164777769280924,0.80627455232773282,0.24712612753947091,0.45110288190407777,0.378505417362413,0.24318120293056167,0.15766881248489584,0.58561590787452744,0.28964263364616205,0.33460187068693009,0.13685230003541035,0.54672683977537695,0.68145542282798299,0],\"text\":[\"AK <br> Pred death rate: 0 <br> 90% pred distn: 0, 0.125\",\"AL <br> Pred death rate: 0.197 <br> 90% pred distn: 0.07, 0.324\",\"AR <br> Pred death rate: 0.513 <br> 90% pred distn: 0.387, 0.64\",\"AS <br> Pred death rate: 0.009 <br> 90% pred distn: 0, 0.136\",\"AZ <br> Pred death rate: 0.603 <br> 90% pred distn: 0.476, 0.73\",\"CA <br> Pred death rate: 0.192 <br> 90% pred distn: 0.065, 0.318\",\"CO <br> Pred death rate: 0.503 <br> 90% pred distn: 0.377, 0.63\",\"CT <br> Pred death rate: 0.422 <br> 90% pred distn: 0.295, 0.548\",\"DC <br> Pred death rate: 0.334 <br> 90% pred distn: 0.207, 0.461\",\"DE <br> Pred death rate: 0.6 <br> 90% pred distn: 0.473, 0.727\",\"FL <br> Pred death rate: 0.266 <br> 90% pred distn: 0.139, 0.392\",\"GA <br> Pred death rate: 0.404 <br> 90% pred distn: 0.278, 0.531\",\"GU <br> Pred death rate: 0.017 <br> 90% pred distn: 0, 0.143\",\"HI <br> Pred death rate: 0.236 <br> 90% pred distn: 0.109, 0.362\",\"IA <br> Pred death rate: 0.295 <br> 90% pred distn: 0.169, 0.422\",\"ID <br> Pred death rate: 0.419 <br> 90% pred distn: 0.292, 0.545\",\"IL <br> Pred death rate: 0.521 <br> 90% pred distn: 0.394, 0.648\",\"IN <br> Pred death rate: 0.681 <br> 90% pred distn: 0.555, 0.808\",\"KS <br> Pred death rate: 0.279 <br> 90% pred distn: 0.152, 0.405\",\"KY <br> Pred death rate: 0.564 <br> 90% pred distn: 0.437, 0.69\",\"LA <br> Pred death rate: 0.116 <br> 90% pred distn: 0, 0.243\",\"MA <br> Pred death rate: 0.599 <br> 90% pred distn: 0.473, 0.726\",\"MD <br> Pred death rate: 1.264 <br> 90% pred distn: 1.137, 1.391\",\"ME <br> Pred death rate: 0.658 <br> 90% pred distn: 0.532, 0.785\",\"MI <br> Pred death rate: 0.843 <br> 90% pred distn: 0.717, 0.97\",\"MN <br> Pred death rate: 0.534 <br> 90% pred distn: 0.407, 0.661\",\"MO <br> Pred death rate: 0.497 <br> 90% pred distn: 0.371, 0.624\",\"MP <br> Pred death rate: 1.291 <br> 90% pred distn: 1.165, 1.418\",\"MS <br> Pred death rate: 0.245 <br> 90% pred distn: 0.118, 0.371\",\"MT <br> Pred death rate: 0.13 <br> 90% pred distn: 0.003, 0.257\",\"NC <br> Pred death rate: 0.287 <br> 90% pred distn: 0.16, 0.413\",\"ND <br> Pred death rate: 0.304 <br> 90% pred distn: 0.177, 0.431\",\"NE <br> Pred death rate: 0.192 <br> 90% pred distn: 0.065, 0.319\",\"NH <br> Pred death rate: 0.874 <br> 90% pred distn: 0.747, 1\",\"NJ <br> Pred death rate: 0.516 <br> 90% pred distn: 0.39, 0.643\",\"NM <br> Pred death rate: 0.665 <br> 90% pred distn: 0.539, 0.792\",\"NV <br> Pred death rate: 0.262 <br> 90% pred distn: 0.135, 0.389\",\"NY <br> Pred death rate: 0.629 <br> 90% pred distn: 0.502, 0.755\",\"OH <br> Pred death rate: 1.116 <br> 90% pred distn: 0.989, 1.243\",\"OK <br> Pred death rate: 0.297 <br> 90% pred distn: 0.171, 0.424\",\"OR <br> Pred death rate: 0.178 <br> 90% pred distn: 0.051, 0.304\",\"PA <br> Pred death rate: 0.795 <br> 90% pred distn: 0.669, 0.922\",\"PR <br> Pred death rate: 0.212 <br> 90% pred distn: 0.085, 0.338\",\"RI <br> Pred death rate: 0.806 <br> 90% pred distn: 0.68, 0.933\",\"SC <br> Pred death rate: 0.247 <br> 90% pred distn: 0.12, 0.374\",\"SD <br> Pred death rate: 0.451 <br> 90% pred distn: 0.324, 0.578\",\"TN <br> Pred death rate: 0.379 <br> 90% pred distn: 0.252, 0.505\",\"TX <br> Pred death rate: 0.243 <br> 90% pred distn: 0.116, 0.37\",\"UT <br> Pred death rate: 0.158 <br> 90% pred distn: 0.031, 0.284\",\"VA <br> Pred death rate: 0.586 <br> 90% pred distn: 0.459, 0.712\",\"VI <br> Pred death rate: 0.29 <br> 90% pred distn: 0.163, 0.416\",\"VT <br> Pred death rate: 0.335 <br> 90% pred distn: 0.208, 0.461\",\"WA <br> Pred death rate: 0.137 <br> 90% pred distn: 0.01, 0.264\",\"WI <br> Pred death rate: 0.547 <br> 90% pred distn: 0.42, 0.673\",\"WV <br> Pred death rate: 0.681 <br> 90% pred distn: 0.555, 0.808\",\"WY <br> Pred death rate: 0 <br> 90% pred distn: 0, 0.093\"],\"hoverinfo\":[\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\"],\"locations\":[\"AK\",\"AL\",\"AR\",\"AS\",\"AZ\",\"CA\",\"CO\",\"CT\",\"DC\",\"DE\",\"FL\",\"GA\",\"GU\",\"HI\",\"IA\",\"ID\",\"IL\",\"IN\",\"KS\",\"KY\",\"LA\",\"MA\",\"MD\",\"ME\",\"MI\",\"MN\",\"MO\",\"MP\",\"MS\",\"MT\",\"NC\",\"ND\",\"NE\",\"NH\",\"NJ\",\"NM\",\"NV\",\"NY\",\"OH\",\"OK\",\"OR\",\"PA\",\"PR\",\"RI\",\"SC\",\"SD\",\"TN\",\"TX\",\"UT\",\"VA\",\"VI\",\"VT\",\"WA\",\"WI\",\"WV\",\"WY\"],\"type\":\"choropleth\",\"marker\":{\"line\":{\"colorbar\":{\"title\":\"\",\"ticklen\":2},\"cmin\":0,\"cmax\":1.2914786888552994,\"colorscale\":[[\"0\",\"rgba(252,251,253,1)\"],[\"0.0416666666666667\",\"rgba(248,246,250,1)\"],[\"0.0833333333333333\",\"rgba(243,242,248,1)\"],[\"0.125\",\"rgba(239,237,245,1)\"],[\"0.166666666666667\",\"rgba(232,231,242,1)\"],[\"0.208333333333333\",\"rgba(225,224,238,1)\"],[\"0.25\",\"rgba(218,218,235,1)\"],[\"0.291666666666667\",\"rgba(208,208,230,1)\"],[\"0.333333333333333\",\"rgba(198,199,225,1)\"],[\"0.375\",\"rgba(188,189,220,1)\"],[\"0.416666666666667\",\"rgba(178,177,213,1)\"],[\"0.458333333333333\",\"rgba(168,166,207,1)\"],[\"0.5\",\"rgba(158,154,200,1)\"],[\"0.541666666666667\",\"rgba(148,144,195,1)\"],[\"0.583333333333333\",\"rgba(138,135,191,1)\"],[\"0.625\",\"rgba(128,125,186,1)\"],[\"0.666666666666667\",\"rgba(121,110,178,1)\"],[\"0.708333333333333\",\"rgba(114,96,171,1)\"],[\"0.75\",\"rgba(106,81,163,1)\"],[\"0.791666666666667\",\"rgba(99,67,156,1)\"],[\"0.833333333333333\",\"rgba(92,54,150,1)\"],[\"0.875\",\"rgba(84,39,143,1)\"],[\"0.916666666666667\",\"rgba(77,28,137,1)\"],[\"0.958333333333333\",\"rgba(70,16,131,1)\"],[\"1\",\"rgba(63,0,125,1)\"]],\"showscale\":false,\"color\":[0,0.19712415389427237,0.51323231200034791,0.0089591812072605699,0.60311520646957695,0.19173956982740087,0.50332222593926335,0.42172131651829653,0.33404200726066013,0.59986038752055704,0.2657191901369545,0.40429344826234903,0.016775762317119604,0.23559684333822983,0.29538261507754571,0.41878925079680412,0.52099171405327749,0.68140468208149052,0.27867671018593088,0.56365659025312653,0.11600977546358786,0.59928619604072042,1.2639073955822999,0.65820588345020226,0.84324878078505539,0.53405334805134452,0.49744841587605432,1.2914786888552994,0.24479784126761184,0.12989447169306448,0.28678925162815616,0.30407826707219554,0.19196578820009205,0.87362717248851818,0.5162795255170004,0.66545426961470688,0.26186428511908411,0.62875934703172298,1.1160846280670333,0.29723050200099393,0.17753469722216142,0.79547856604253253,0.21164777769280924,0.80627455232773282,0.24712612753947091,0.45110288190407777,0.378505417362413,0.24318120293056167,0.15766881248489584,0.58561590787452744,0.28964263364616205,0.33460187068693009,0.13685230003541035,0.54672683977537695,0.68145542282798299,0]}},\"geo\":\"geo\",\"frame\":null}],\"highlight\":{\"on\":\"plotly_click\",\"persistent\":false,\"dynamic\":false,\"selectize\":false,\"opacityDim\":0.20000000000000001,\"selected\":{\"opacity\":1},\"debounce\":0},\"shinyEvents\":[\"plotly_hover\",\"plotly_click\",\"plotly_selected\",\"plotly_relayout\",\"plotly_brushed\",\"plotly_brushing\",\"plotly_clickannotation\",\"plotly_doubleclick\",\"plotly_deselect\",\"plotly_afterplot\",\"plotly_sunburstclick\"],\"base_url\":\"https://plot.ly\"},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\nPretty cool for a quick adaptation of existing `plotly` code. \n\nAt this point, it is good to do your own sanity check to make sure that the prediction values shown on the plot match up to those shown in the output (`all_the_states$predictions`) for each state. From our quick inspection, this checks out.\n\nFinally, it's good to consider what modifications we could make to improve the plot... For instance, if we had the true death rates for that date, then we could show these on the same or on another chloropleth map that's side-by-side to this one. We'll leave it to the reader to try such extensions on their own.\n\n## Attribution\n\nThis vignette was largely adapted from [Chapter 3 of ISLR tidymodels labs](https://emilhvitfeldt.github.io/ISLR-tidymodels-labs/03-linear-regression.html). \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/htmlwidgets-1.6.2/htmlwidgets.js\"></script>\n<script src=\"site_libs/plotly-binding-4.10.2/plotly.js\"></script>\n<script src=\"site_libs/typedarray-0.1/typedarray.min.js\"></script>\n<script src=\"site_libs/jquery-3.5.1/jquery.min.js\"></script>\n<link href=\"site_libs/crosstalk-1.2.0/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/crosstalk-1.2.0/js/crosstalk.min.js\"></script>\n<link href=\"site_libs/plotly-htmlwidgets-css-2.11.1/plotly-htmlwidgets.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/plotly-main-2.11.1/plotly-latest.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
{
  "hash": "d46b11b81cb12f35b6303e27958c7c23",
  "result": {
    "markdown": "# Regression in Tidymodels - Part 2\n\n\n::: {.cell}\n\n:::\n\n\n## Libraries and data\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-2_2c39d10eba215aedfac490542d500110'}\n\n```{.r .cell-code}\n# Load necessary packages\nlibrary(tidymodels)\nlibrary(plotly)\n```\n:::\n\n\nAs a follow-up to the [Regression in Tidymodels chapter](tidymodels-regression.qmd), we're going to look at how the functions we used to perform linear regression fare when applied to a small set of epidemiological time series data. We'll be working with the built-in JHU data on daily confirmed COVID-19 case and death rates for California over Dec. 31, 2020 to Dec. 31, 2021.\n\nNote that while data is available for all states, we're focusing on just one state's worth of data to avoid having to manage multiple regions (panel data). \n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-3_285a3f7cc79d33f0328599de942fcaa4'}\n\n```{.r .cell-code}\n# Load and subset data\nca_case_death_rate_subset <- case_death_rate_subset %>%\n  filter(geo_value == \"ca\")\n```\n:::\n\n\n## Simple linear regression\n\nOur goal for this exercise is to construct a simple linear regression model of daily death rate as a function of daily case rate. To do this, we'll apply the sequence of steps to build a model that we went through in the previous chapter (only in a different scenario). Thus, we'll opt for the same linear regression model specification. \n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-4_9d2c534c117001f34f0ffec4c97ca8ee'}\n::: {.cell-output-display}\n![](img/set_engine.png){fig-align='center' width=50%}\n:::\n:::\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-5_8e4a55d2cf5dd5462ea1ea929bd3f6f8'}\n\n```{.r .cell-code}\nlm_spec <- linear_reg()\n```\n:::\n\n\nWe made two simplifications to the linear regression model specification shown in the previous chapter. Firstly, setting the mode is unnecessary for linear regression, and, secondly, `lm` is the default engine for linear regression, so we do not have to include either.\n\nNow we fit our model by inputting the formula (of the form `y ~ x`) `death_rate ~ case_rate` and the `ca_case_death_rate_subset` into the `fit()` function.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-6_bdf235a5206620fbc7d51847c37e572d'}\n\n```{.r .cell-code}\nca_lm_fit <- lm_spec %>%\n  fit(death_rate ~ case_rate, data = ca_case_death_rate_subset)\nca_lm_fit\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> parsnip model object\n#> \n#> \n#> Call:\n#> stats::lm(formula = death_rate ~ case_rate, data = data)\n#> \n#> Coefficients:\n#> (Intercept)    case_rate  \n#>    0.158168     0.009175\n```\n:::\n:::\n\n\nAs before, let's use `purrr`’s `pluck()` function to access the underlying fit and then pipe that into `summary()` to get a basic synopsis of our model.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-7_c75b0213d815c274ab67c3fa1cb68811'}\n\n```{.r .cell-code}\nca_lm_fit %>%\n  pluck(\"fit\") %>%\n  summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n#> Call:\n#> stats::lm(formula = death_rate ~ case_rate, data = data)\n#> \n#> Residuals:\n#>      Min       1Q   Median       3Q      Max \n#> -0.79039 -0.14212 -0.07560  0.02259  0.87239 \n#> \n#> Coefficients:\n#>              Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept) 0.1581681  0.0213029   7.425 8.09e-13 ***\n#> case_rate   0.0091755  0.0006504  14.107  < 2e-16 ***\n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> Residual standard error: 0.3021 on 364 degrees of freedom\n#> Multiple R-squared:  0.3535,\tAdjusted R-squared:  0.3517 \n#> F-statistic:   199 on 1 and 364 DF,  p-value: < 2.2e-16\n```\n:::\n:::\n\n\nNow we may generate predictions for the dataset. \n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-8_aa8fab980d307cfa71a1213383688695'}\n\n```{.r .cell-code}\npredict(ca_lm_fit, new_data = ca_case_death_rate_subset)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 366 × 1\n#>   .pred\n#>   <dbl>\n#> 1  1.04\n#> 2  1.12\n#> 3  1.10\n#> 4  1.09\n#> 5  1.09\n#> 6  1.09\n#> # ℹ 360 more rows\n```\n:::\n:::\n\nTo get a side-by-side view of the observed and predicted values for an informal comparison, we'll use `augment()`.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-9_a16c95fbd9e3ef41769d07e6f19f39e9'}\n\n```{.r .cell-code}\n# adjoin the model predictions to `ca_case_death_rate_subset`).\naugment(ca_lm_fit, new_data = ca_case_death_rate_subset) %>%\n  select(death_rate, .pred)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 366 × 2\n#>   death_rate .pred\n#>        <dbl> <dbl>\n#> 1      0.751  1.04\n#> 2      0.850  1.12\n#> 3      0.857  1.10\n#> 4      0.860  1.09\n#> 5      0.911  1.09\n#> 6      0.908  1.09\n#> # ℹ 360 more rows\n```\n:::\n:::\n\n\nAll in all, everything that we did before seems to translate seamlessly over to handling this epidemiological time series data. But realistically, if we're tasked with predicting COVID-19 deaths, we do not only want to consider the concurrent case information. Since what happened in the past can inform us where things are heading, it is natural to include past case rates and death rates as predictors.\n\n## Adding lagged predictors and predicting for a target date\n\nAt this point, it is important to consider how far back in the past to look. More specifically, we should consider what past case and death rates are most predictive of current deaths. If you are interested, conducting a lagged correlation analysis as in the [Correlate signals over space and time chapter](correlations.qmd) is one way to start exploring this. We will not take that route because it ventures into model selection territory, which is beyond the scope of this article. Instead, we will take a more ad hoc approach for deciding what lagged predictors to include.\n\nTo begin, we will add predictors for the lagged 1-day death and case rates as those seem to be the most sensible choices (because it is reasonable to expect that yesterday is more predictive of today than two weeks ago).\n\nSo first, let's add a column for the lagged 1-day death rates by using `dplyr`'s `mutate()` function.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-10_a109c0cce6077fa034dfa6482d916f26'}\n\n```{.r .cell-code}\nca_subset_wlag <- ca_case_death_rate_subset %>%\n  mutate(lag_1_death_rate = lag(death_rate, 1))\n```\n:::\n\n\nThen, we can create our recipe, adding a `lag_1_day_case_rate` column in the same way as we added a non-linear transformation of a predictor previously - by using `step_mutate()` on the predictor that's been specified in the recipe formula.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-11_3053fccd91b5661f92aa86d6087ee54c'}\n\n```{.r .cell-code}\nrec_spec_wlag <- recipe(death_rate ~ case_rate + lag_1_death_rate, data = ca_subset_wlag) %>%\n  step_mutate(lag_1_case_rate = lag(case_rate, 1))\n```\n:::\n\n\nNext, we input the model and recipe into our workflow and then fit the model to our dataset in the same way as we did before.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-12_d001ce8805d69846f1eef56be8685456'}\n\n```{.r .cell-code}\nlm_wf_lag <- workflow() %>%\n  add_model(lm_spec) %>%\n  add_recipe(rec_spec_wlag)\n\nca_lm_fit_lag <- lm_wf_lag %>% fit(ca_subset_wlag)\nca_lm_fit_lag\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> ══ Workflow [trained] ═══════════════════════════════════════════════════════\n#> Preprocessor: Recipe\n#> Model: linear_reg()\n#> \n#> ── Preprocessor ─────────────────────────────────────────────────────────────\n#> 1 Recipe Step\n#> \n#> • step_mutate()\n#> \n#> ── Model ────────────────────────────────────────────────────────────────────\n#> \n#> Call:\n#> stats::lm(formula = ..y ~ ., data = data)\n#> \n#> Coefficients:\n#>      (Intercept)         case_rate  lag_1_death_rate   lag_1_case_rate  \n#>       -0.0040422         0.0013087         0.9793506        -0.0008568\n```\n:::\n:::\n\n\nAs a result, we obtain a trained workflow that has undergone both pre-processing (`step_mutate` to add the 1-day lagged case rate as a predictor) and model fitting. \n\nNow, we'll use our model to predict the death rate for a day beyond the last in the dataset (so our target date is Jan. 1, 2022). Suppose that a reliable source tells us that the case rate for that day is 84.7 (cases per 100,000 population). From the last row of our dataset, we can see that the lagged 1-day case rate is about 84.4 and the lagged death rate is about 0.142 (deaths per 100,000 population). We'll put this information in a short dataframe:\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-13_aa9511094763cc41fbd6d3b12835ccf8'}\n\n```{.r .cell-code}\nca_jan1_df <- data.frame(\n  geo_value = \"ca\",\n  time_value = as.Date(\"2022-01-01\"),\n  case_rate = 84.7,\n  lag_1_death_rate = last(ca_subset_wlag)$death_rate\n)\n```\n:::\n\n\nNotice that we included `lag_1_death_rate`, but no `lag_1_case_rate` in the above dataframe. The reason for this is that there is `lag_1_death_rate` in the `ca_subset_wlag` dataset that we used to construct the recipe. So the recipe expects that variable. In contrast, we used `step_mutate` to dynamically add the lagged case rate variable as a predictor. It was not part of the original recipe specification. This means that we do not want to designate a variable `lag_1_case_rate`, rather we just need enough rows of data in `new_data` so that when it undergoes the pre-processing step, that step can reach back to grab the lagged 1-day case rate from the `case_rate` variable. The easy way to ensure this can happen is to append `jan_1_df` to `ca_subset_wlag` using `bind_rows()`:\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-14_2fe2f73c5a3dbe0b0f2478e7deba2ea6'}\n\n```{.r .cell-code}\n# Add new row of to ca_subset_wlag\nca_subset_wlag_jan1 <- bind_rows(\n  ca_subset_wlag,\n  ca_jan1_df\n)\n```\n:::\n\n\nAnd then input that into predict...\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-15_0c8d22a80615f73c3899ca17a3d35f1d'}\n\n```{.r .cell-code}\npredict(ca_lm_fit_lag, new_data = ca_subset_wlag_jan1) %>%\n  tail(n = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 1 × 1\n#>   .pred\n#>   <dbl>\n#> 1 0.173\n```\n:::\n:::\n\nWonderful. We've successfully obtained a prediction. But it was a lot of work to to force recipes work with such data. How can we simplify things for ourselves? Well `epipredict` offers two clear options...\n\n### Option 1 - manually create our own `epi_recipe`\n\nIt is more advantageous to use an `epi_recipe` than a `recipe` on an `epi_df` because it unlocks a number of features specific to epidemiological data such as tailored pre-processing steps like creating columns of lagged data. So, instead of using the `mutate()` and `step_mutate()` combination to get the lagged case and death rate variables, we can write the following where we use `step_epi_lag` to lag the predictors and specify how far ahead we want to predict the outcome using `step_epi_ahead`.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-16_e2a37e8f587941899cfb661c9593a47a'}\n\n```{.r .cell-code}\nca_epi_r <- epi_recipe(ca_case_death_rate_subset) %>%\n  step_epi_lag(case_rate, lag = c(0, 1)) %>%\n  step_epi_lag(death_rate, lag = 1) %>%\n  step_epi_ahead(death_rate, ahead = 0)\n```\n:::\n\n\nThen, input the `epi_recipe` into an `epi_workflow()`, fit the linear model, and predict in the same way as before.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-17_a96c7f12005fcc2817806330f5d3d081'}\n\n```{.r .cell-code}\nca_epi_wf <- epi_workflow(ca_epi_r, lm_spec) %>%\n  fit(ca_case_death_rate_subset)\n\npredict(ca_epi_wf, ca_subset_wlag_jan1 %>% select(-lag_1_death_rate)) %>%\n  filter(time_value == \"2022-01-01\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> An `epi_df` object, 1 x 3 with metadata:\n#> * geo_type  = state\n#> * time_type = day\n#> * as_of     = 2022-05-31 12:08:25.791826\n#> \n#> # A tibble: 1 × 3\n#>   geo_value time_value .pred\n#> * <chr>     <date>     <dbl>\n#> 1 ca        2022-01-01 0.173\n```\n:::\n:::\n\n\nAs expected, we obtain the same prediction as when we used the first approach.\n\n### Option 2 - let the `arx_forecaster()` do the work for us\n\nThe `epipredict` package has the `arx_forecaster()` function that pre-processes, trains the model, predicts, and performs some basic post-processing all in one go. The reason why we can use this model is that the task of predicting the death rate for one day ahead using the lagged 1-day death and case rates is a type of autoregressive (AR) model (in which a linear combination of previous values are use forecast the variable of interest). \n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-18_9739aad549f8766041f4db73dc9b21e6'}\n\n```{.r .cell-code}\nca_arx_jan_22 <- arx_forecaster(\n  ca_subset_wlag_jan1 %>% select(-lag_1_death_rate),\n  outcome = \"death_rate\",\n  predictors = c(\"death_rate\", \"case_rate\"),\n  args_list = arx_args_list(\n    lags = list(death_rate = c(1), case_rate = c(0, 1)),\n    ahead = 0L\n  )\n)\nca_arx_jan_22$predictions\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 1 × 5\n#>   geo_value .pred         .pred_distn forecast_date target_date\n#>   <chr>     <dbl>              <dist> <date>        <date>     \n#> 1 ca        0.173 [0.05, 0.95]<q-rng> 2022-01-01    2022-01-01\n```\n:::\n:::\n\nWe can easily add more lags for the case and death rates into the function. All that we must do is add a couple of choice numbers to the `lags` argument. This is preferable to the (longwinded) alternative of adding them one by one to `step_mutate()`. So let's go ahead and try adding various lags for the case and death rates to `arx_forecaster()`:\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-19_f4989c3184965d788fd29f19a9611a30'}\n\n```{.r .cell-code}\nlots_of_lags_ca <- arx_forecaster(\n  ca_subset_wlag_jan1 %>% select(-lag_1_death_rate),\n  outcome = \"death_rate\",\n  predictors = c(\"case_rate\", \"death_rate\"),\n  args_list = arx_args_list(\n    lags = list(case_rate = c(0, 1, 2, 3, 4, 7), death_rate = c(1, 2, 3, 4, 7)),\n    ahead = 0L\n  )\n)\nlots_of_lags_ca$predictions\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 1 × 5\n#>   geo_value .pred         .pred_distn forecast_date target_date\n#>   <chr>     <dbl>              <dist> <date>        <date>     \n#> 1 ca        0.106 [0.05, 0.95]<q-rng> 2022-01-01    2022-01-01\n```\n:::\n:::\n\n\nThe other major benefit of the forecaster is that it is equipped to handle panel data. This means that we could input several other states worth of data, and get a prediction for each state. For example, we can try plugging in the entirety of the original `case_death_rate_subset` and get a prediction of the death rate on Jan. 1, 2022 for each state: \n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-20_d6fbfbec04c3b860c6788bbf25e7b600'}\n\n```{.r .cell-code}\nall_the_states <- arx_forecaster(\n  case_death_rate_subset,\n  outcome = \"death_rate\",\n  predictors = c(\"case_rate\", \"death_rate\"),\n  args_list = arx_args_list(\n    lags = list(c(0, 1, 2, 3, 4, 7), c(1, 2, 3, 4, 7)),\n    ahead = 1L\n  )\n)\nall_the_states$predictions\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 56 × 5\n#>   geo_value   .pred         .pred_distn forecast_date target_date\n#>   <chr>       <dbl>              <dist> <date>        <date>     \n#> 1 ak        0       [0.05, 0.95]<q-rng> 2021-12-31    2022-01-01 \n#> 2 al        0.197   [0.05, 0.95]<q-rng> 2021-12-31    2022-01-01 \n#> 3 ar        0.513   [0.05, 0.95]<q-rng> 2021-12-31    2022-01-01 \n#> 4 as        0.00896 [0.05, 0.95]<q-rng> 2021-12-31    2022-01-01 \n#> 5 az        0.603   [0.05, 0.95]<q-rng> 2021-12-31    2022-01-01 \n#> 6 ca        0.192   [0.05, 0.95]<q-rng> 2021-12-31    2022-01-01 \n#> # ℹ 50 more rows\n```\n:::\n:::\n\n\nAwesome! We'll learn more about this and other forecasters in later chapters.\n\n## Interactive plot of predictions {#sec-interactive-plot}\n\nLet's finish off by producing an interactive `plotly` choropleth map of our above predictions (along with the 90% predictive intervals) to get a sense of how they may be geospatially related.\n\nFirst we'll ready our data. The key part is the extraction of the quantiles that make up the 90% predictive intervals. These are by default contained inside a distribution (`.pred_distn`) which we must unnest to get to.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-21_fab146b9a2df02676de7ded1301578cd'}\n\n```{.r .cell-code}\n# Rename df of predictions to shorten up\nall_the_states_df <- all_the_states$predictions\n\n# Extract nested quantiles\nall_the_states_df <- all_the_states_df %>%\n  mutate(q = nested_quantiles(.pred_distn)) %>%\n  unnest(q) %>%\n  pivot_wider(names_from = tau, values_from = q)\n```\n:::\n\n\nThen, we adapted the \"Customize choropleth code\" from the [plotly website](https://plotly.com/r/choropleth-maps/) to our data. The two major changes we made are that we specified the text we would like to reveal when we hover (the predictions and the corresponding 90% predictive interval) and we modified the trace so that the predictions determine the colour of the state and the locations are based on the state abbreviations in `geo_value`.\n\n\n::: {.cell layout-align=\"center\" hash='tidymodels-regression-part2_cache/html/unnamed-chunk-22_39e447856a7ca6e1873a7e60b6edba78'}\n\n```{.r .cell-code  code-fold=\"true\"}\n# See on hover\nall_the_states_df$hover <- with(\n  all_the_states_df,\n  paste(\n    toupper(geo_value), \"<br>\",\n    \"Pred death rate:\", round(.pred, digits = 3), \"<br>\",\n    \"90% pred distn:\", paste(round(`0.05`, digits = 3),\n      round(`0.95`, digits = 3),\n      sep = \", \"\n    )\n  )\n)\n\n# Give state boundaries a white border\nl <- list(color = toRGB(\"white\"), width = 2)\n\n# Specify some map projection/options\ng <- list(\n  scope = \"usa\",\n  projection = list(type = \"albers usa\"),\n  showlakes = TRUE,\n  lakecolor = toRGB(\"white\")\n)\n\nfig <- plot_geo(all_the_states_df, locationmode = \"USA-states\")\nfig <- fig %>% add_trace(\n  z = ~.pred, text = ~hover, hoverinfo = \"text\", locations = ~ toupper(geo_value),\n  color = ~.pred, colors = \"Purples\"\n)\n\n# Add titles and such\nfig <- fig %>% colorbar(title = \"Death rate\")\nfig <- fig %>% layout(\n  title = \"2022-01-01 predicted death rate (per 100,000) by state<br>(Hover for breakdown)\",\n  geo = g\n)\n\nfig\n```\n\n::: {.cell-output-display}\n```{=html}\n<div class=\"plotly html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-47f11ee08e16179b1b17\" style=\"width:90%;height:525px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-47f11ee08e16179b1b17\">{\"x\":{\"visdat\":{\"6a547e2deb68\":[\"function () \",\"plotlyVisDat\"]},\"cur_data\":\"6a547e2deb68\",\"attrs\":{\"6a547e2deb68\":{\"locationmode\":\"USA-states\",\"alpha_stroke\":1,\"sizes\":[10,100],\"spans\":[1,20],\"z\":{},\"text\":{},\"hoverinfo\":\"text\",\"locations\":{},\"color\":{},\"colors\":\"Purples\",\"inherit\":true}},\"layout\":{\"margin\":{\"b\":40,\"l\":60,\"t\":25,\"r\":10},\"mapType\":\"geo\",\"scene\":{\"zaxis\":{\"title\":\".pred\"}},\"geo\":{\"domain\":{\"x\":[0,1],\"y\":[0,1]},\"scope\":\"usa\",\"projection\":{\"type\":\"albers usa\"},\"showlakes\":true,\"lakecolor\":\"rgba(255,255,255,1)\"},\"hovermode\":\"closest\",\"showlegend\":false,\"legend\":{\"yanchor\":\"top\",\"y\":0.5},\"title\":\"2022-01-01 predicted death rate (per 100,000) by state<br>(Hover for breakdown)\"},\"source\":\"A\",\"config\":{\"modeBarButtonsToAdd\":[\"hoverclosest\",\"hovercompare\"],\"showSendToCloud\":false},\"data\":[{\"colorbar\":{\"title\":\"Death rate\",\"ticklen\":2,\"len\":0.5,\"lenmode\":\"fraction\",\"y\":1,\"yanchor\":\"top\"},\"colorscale\":[[\"0\",\"rgba(252,251,253,1)\"],[\"0.0416666666666667\",\"rgba(248,246,250,1)\"],[\"0.0833333333333333\",\"rgba(243,242,248,1)\"],[\"0.125\",\"rgba(239,237,245,1)\"],[\"0.166666666666667\",\"rgba(232,231,242,1)\"],[\"0.208333333333333\",\"rgba(225,224,238,1)\"],[\"0.25\",\"rgba(218,218,235,1)\"],[\"0.291666666666667\",\"rgba(208,208,230,1)\"],[\"0.333333333333333\",\"rgba(198,199,225,1)\"],[\"0.375\",\"rgba(188,189,220,1)\"],[\"0.416666666666667\",\"rgba(178,177,213,1)\"],[\"0.458333333333333\",\"rgba(168,166,207,1)\"],[\"0.5\",\"rgba(158,154,200,1)\"],[\"0.541666666666667\",\"rgba(148,144,195,1)\"],[\"0.583333333333333\",\"rgba(138,135,191,1)\"],[\"0.625\",\"rgba(128,125,186,1)\"],[\"0.666666666666667\",\"rgba(121,110,178,1)\"],[\"0.708333333333333\",\"rgba(114,96,171,1)\"],[\"0.75\",\"rgba(106,81,163,1)\"],[\"0.791666666666667\",\"rgba(99,67,156,1)\"],[\"0.833333333333333\",\"rgba(92,54,150,1)\"],[\"0.875\",\"rgba(84,39,143,1)\"],[\"0.916666666666667\",\"rgba(77,28,137,1)\"],[\"0.958333333333333\",\"rgba(70,16,131,1)\"],[\"1\",\"rgba(63,0,125,1)\"]],\"showscale\":true,\"locationmode\":\"USA-states\",\"z\":[0,0.19712415389427237,0.51323231200034791,0.0089591812072605699,0.60311520646957695,0.19173956982740087,0.50332222593926335,0.42172131651829653,0.33404200726066013,0.59986038752055704,0.2657191901369545,0.40429344826234903,0.016775762317119604,0.23559684333822983,0.29538261507754571,0.41878925079680412,0.52099171405327749,0.68140468208149052,0.27867671018593088,0.56365659025312653,0.11600977546358786,0.59928619604072042,1.2639073955822999,0.65820588345020226,0.84324878078505539,0.53405334805134452,0.49744841587605432,1.2914786888552994,0.24479784126761184,0.12989447169306448,0.28678925162815616,0.30407826707219554,0.19196578820009205,0.87362717248851818,0.5162795255170004,0.66545426961470688,0.26186428511908411,0.62875934703172298,1.1160846280670333,0.29723050200099393,0.17753469722216142,0.79547856604253253,0.21164777769280924,0.80627455232773282,0.24712612753947091,0.45110288190407777,0.378505417362413,0.24318120293056167,0.15766881248489584,0.58561590787452744,0.28964263364616205,0.33460187068693009,0.13685230003541035,0.54672683977537695,0.68145542282798299,0],\"text\":[\"AK <br> Pred death rate: 0 <br> 90% pred distn: 0, 0.125\",\"AL <br> Pred death rate: 0.197 <br> 90% pred distn: 0.07, 0.324\",\"AR <br> Pred death rate: 0.513 <br> 90% pred distn: 0.387, 0.64\",\"AS <br> Pred death rate: 0.009 <br> 90% pred distn: 0, 0.136\",\"AZ <br> Pred death rate: 0.603 <br> 90% pred distn: 0.476, 0.73\",\"CA <br> Pred death rate: 0.192 <br> 90% pred distn: 0.065, 0.318\",\"CO <br> Pred death rate: 0.503 <br> 90% pred distn: 0.377, 0.63\",\"CT <br> Pred death rate: 0.422 <br> 90% pred distn: 0.295, 0.548\",\"DC <br> Pred death rate: 0.334 <br> 90% pred distn: 0.207, 0.461\",\"DE <br> Pred death rate: 0.6 <br> 90% pred distn: 0.473, 0.727\",\"FL <br> Pred death rate: 0.266 <br> 90% pred distn: 0.139, 0.392\",\"GA <br> Pred death rate: 0.404 <br> 90% pred distn: 0.278, 0.531\",\"GU <br> Pred death rate: 0.017 <br> 90% pred distn: 0, 0.143\",\"HI <br> Pred death rate: 0.236 <br> 90% pred distn: 0.109, 0.362\",\"IA <br> Pred death rate: 0.295 <br> 90% pred distn: 0.169, 0.422\",\"ID <br> Pred death rate: 0.419 <br> 90% pred distn: 0.292, 0.545\",\"IL <br> Pred death rate: 0.521 <br> 90% pred distn: 0.394, 0.648\",\"IN <br> Pred death rate: 0.681 <br> 90% pred distn: 0.555, 0.808\",\"KS <br> Pred death rate: 0.279 <br> 90% pred distn: 0.152, 0.405\",\"KY <br> Pred death rate: 0.564 <br> 90% pred distn: 0.437, 0.69\",\"LA <br> Pred death rate: 0.116 <br> 90% pred distn: 0, 0.243\",\"MA <br> Pred death rate: 0.599 <br> 90% pred distn: 0.473, 0.726\",\"MD <br> Pred death rate: 1.264 <br> 90% pred distn: 1.137, 1.391\",\"ME <br> Pred death rate: 0.658 <br> 90% pred distn: 0.532, 0.785\",\"MI <br> Pred death rate: 0.843 <br> 90% pred distn: 0.717, 0.97\",\"MN <br> Pred death rate: 0.534 <br> 90% pred distn: 0.407, 0.661\",\"MO <br> Pred death rate: 0.497 <br> 90% pred distn: 0.371, 0.624\",\"MP <br> Pred death rate: 1.291 <br> 90% pred distn: 1.165, 1.418\",\"MS <br> Pred death rate: 0.245 <br> 90% pred distn: 0.118, 0.371\",\"MT <br> Pred death rate: 0.13 <br> 90% pred distn: 0.003, 0.257\",\"NC <br> Pred death rate: 0.287 <br> 90% pred distn: 0.16, 0.413\",\"ND <br> Pred death rate: 0.304 <br> 90% pred distn: 0.177, 0.431\",\"NE <br> Pred death rate: 0.192 <br> 90% pred distn: 0.065, 0.319\",\"NH <br> Pred death rate: 0.874 <br> 90% pred distn: 0.747, 1\",\"NJ <br> Pred death rate: 0.516 <br> 90% pred distn: 0.39, 0.643\",\"NM <br> Pred death rate: 0.665 <br> 90% pred distn: 0.539, 0.792\",\"NV <br> Pred death rate: 0.262 <br> 90% pred distn: 0.135, 0.389\",\"NY <br> Pred death rate: 0.629 <br> 90% pred distn: 0.502, 0.755\",\"OH <br> Pred death rate: 1.116 <br> 90% pred distn: 0.989, 1.243\",\"OK <br> Pred death rate: 0.297 <br> 90% pred distn: 0.171, 0.424\",\"OR <br> Pred death rate: 0.178 <br> 90% pred distn: 0.051, 0.304\",\"PA <br> Pred death rate: 0.795 <br> 90% pred distn: 0.669, 0.922\",\"PR <br> Pred death rate: 0.212 <br> 90% pred distn: 0.085, 0.338\",\"RI <br> Pred death rate: 0.806 <br> 90% pred distn: 0.68, 0.933\",\"SC <br> Pred death rate: 0.247 <br> 90% pred distn: 0.12, 0.374\",\"SD <br> Pred death rate: 0.451 <br> 90% pred distn: 0.324, 0.578\",\"TN <br> Pred death rate: 0.379 <br> 90% pred distn: 0.252, 0.505\",\"TX <br> Pred death rate: 0.243 <br> 90% pred distn: 0.116, 0.37\",\"UT <br> Pred death rate: 0.158 <br> 90% pred distn: 0.031, 0.284\",\"VA <br> Pred death rate: 0.586 <br> 90% pred distn: 0.459, 0.712\",\"VI <br> Pred death rate: 0.29 <br> 90% pred distn: 0.163, 0.416\",\"VT <br> Pred death rate: 0.335 <br> 90% pred distn: 0.208, 0.461\",\"WA <br> Pred death rate: 0.137 <br> 90% pred distn: 0.01, 0.264\",\"WI <br> Pred death rate: 0.547 <br> 90% pred distn: 0.42, 0.673\",\"WV <br> Pred death rate: 0.681 <br> 90% pred distn: 0.555, 0.808\",\"WY <br> Pred death rate: 0 <br> 90% pred distn: 0, 0.093\"],\"hoverinfo\":[\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\",\"text\"],\"locations\":[\"AK\",\"AL\",\"AR\",\"AS\",\"AZ\",\"CA\",\"CO\",\"CT\",\"DC\",\"DE\",\"FL\",\"GA\",\"GU\",\"HI\",\"IA\",\"ID\",\"IL\",\"IN\",\"KS\",\"KY\",\"LA\",\"MA\",\"MD\",\"ME\",\"MI\",\"MN\",\"MO\",\"MP\",\"MS\",\"MT\",\"NC\",\"ND\",\"NE\",\"NH\",\"NJ\",\"NM\",\"NV\",\"NY\",\"OH\",\"OK\",\"OR\",\"PA\",\"PR\",\"RI\",\"SC\",\"SD\",\"TN\",\"TX\",\"UT\",\"VA\",\"VI\",\"VT\",\"WA\",\"WI\",\"WV\",\"WY\"],\"type\":\"choropleth\",\"marker\":{\"line\":{\"colorbar\":{\"title\":\"\",\"ticklen\":2},\"cmin\":0,\"cmax\":1.2914786888552994,\"colorscale\":[[\"0\",\"rgba(252,251,253,1)\"],[\"0.0416666666666667\",\"rgba(248,246,250,1)\"],[\"0.0833333333333333\",\"rgba(243,242,248,1)\"],[\"0.125\",\"rgba(239,237,245,1)\"],[\"0.166666666666667\",\"rgba(232,231,242,1)\"],[\"0.208333333333333\",\"rgba(225,224,238,1)\"],[\"0.25\",\"rgba(218,218,235,1)\"],[\"0.291666666666667\",\"rgba(208,208,230,1)\"],[\"0.333333333333333\",\"rgba(198,199,225,1)\"],[\"0.375\",\"rgba(188,189,220,1)\"],[\"0.416666666666667\",\"rgba(178,177,213,1)\"],[\"0.458333333333333\",\"rgba(168,166,207,1)\"],[\"0.5\",\"rgba(158,154,200,1)\"],[\"0.541666666666667\",\"rgba(148,144,195,1)\"],[\"0.583333333333333\",\"rgba(138,135,191,1)\"],[\"0.625\",\"rgba(128,125,186,1)\"],[\"0.666666666666667\",\"rgba(121,110,178,1)\"],[\"0.708333333333333\",\"rgba(114,96,171,1)\"],[\"0.75\",\"rgba(106,81,163,1)\"],[\"0.791666666666667\",\"rgba(99,67,156,1)\"],[\"0.833333333333333\",\"rgba(92,54,150,1)\"],[\"0.875\",\"rgba(84,39,143,1)\"],[\"0.916666666666667\",\"rgba(77,28,137,1)\"],[\"0.958333333333333\",\"rgba(70,16,131,1)\"],[\"1\",\"rgba(63,0,125,1)\"]],\"showscale\":false,\"color\":[0,0.19712415389427237,0.51323231200034791,0.0089591812072605699,0.60311520646957695,0.19173956982740087,0.50332222593926335,0.42172131651829653,0.33404200726066013,0.59986038752055704,0.2657191901369545,0.40429344826234903,0.016775762317119604,0.23559684333822983,0.29538261507754571,0.41878925079680412,0.52099171405327749,0.68140468208149052,0.27867671018593088,0.56365659025312653,0.11600977546358786,0.59928619604072042,1.2639073955822999,0.65820588345020226,0.84324878078505539,0.53405334805134452,0.49744841587605432,1.2914786888552994,0.24479784126761184,0.12989447169306448,0.28678925162815616,0.30407826707219554,0.19196578820009205,0.87362717248851818,0.5162795255170004,0.66545426961470688,0.26186428511908411,0.62875934703172298,1.1160846280670333,0.29723050200099393,0.17753469722216142,0.79547856604253253,0.21164777769280924,0.80627455232773282,0.24712612753947091,0.45110288190407777,0.378505417362413,0.24318120293056167,0.15766881248489584,0.58561590787452744,0.28964263364616205,0.33460187068693009,0.13685230003541035,0.54672683977537695,0.68145542282798299,0]}},\"geo\":\"geo\",\"frame\":null}],\"highlight\":{\"on\":\"plotly_click\",\"persistent\":false,\"dynamic\":false,\"selectize\":false,\"opacityDim\":0.20000000000000001,\"selected\":{\"opacity\":1},\"debounce\":0},\"shinyEvents\":[\"plotly_hover\",\"plotly_click\",\"plotly_selected\",\"plotly_relayout\",\"plotly_brushed\",\"plotly_brushing\",\"plotly_clickannotation\",\"plotly_doubleclick\",\"plotly_deselect\",\"plotly_afterplot\",\"plotly_sunburstclick\"],\"base_url\":\"https://plot.ly\"},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\nNot bad for a quick adaptation of existing `plotly` code. \n\nAt this point, it is good to do your own sanity check to make sure that the prediction values shown on the plot match up to those shown in the output (`all_the_states$predictions`) for each state. From our quick inspection, that checks out.\n\nFinally, it's good to consider what modifications we could make to improve the plot. For instance, if we had the true death rates, then we could show them on the same or on another choropleth map that's side-by-side to the one with the predictions. We'll leave it to the reader to try implementing such extensions on their own.\n\n## Attribution\n\nThis vignette was largely adapted from [Chapter 3 of ISLR tidymodels labs](https://emilhvitfeldt.github.io/ISLR-tidymodels-labs/03-linear-regression.html). \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/htmlwidgets-1.6.2/htmlwidgets.js\"></script>\n<script src=\"site_libs/plotly-binding-4.10.2/plotly.js\"></script>\n<script src=\"site_libs/typedarray-0.1/typedarray.min.js\"></script>\n<script src=\"site_libs/jquery-3.5.1/jquery.min.js\"></script>\n<link href=\"site_libs/crosstalk-1.2.0/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/crosstalk-1.2.0/js/crosstalk.min.js\"></script>\n<link href=\"site_libs/plotly-htmlwidgets-css-2.11.1/plotly-htmlwidgets.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/plotly-main-2.11.1/plotly-latest.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}